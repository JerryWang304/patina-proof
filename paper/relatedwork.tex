\section*{Related Work}

Safe dialects of C, unique pointers, borrowed references, 
regions, and other topics relevant to Rust each have long
and full histories. Rather than attempt to catalogue them in detail
and compare Rust with each of its ancestors, we will limit our discussion
to the most closely related work we are aware of.

Both ML Kit \cite{mlkit-4.3.0, mlkitregions}
and Cyclone \cite{cycregions} heavily influenced the design of Rust.
However, both of those languages, along with most research in the area,
uses regions for memory management. In constrast, Rust's memory is managed
by affine types (unique ownership), and uses regions (lifetimes in Rust)
more for ensuring the safety of borrowed references than for managing memory.
Cyclone's region subtyping is the source of Rust's lifetime subtyping
and so they ensure references do not escape in a similar fashion.
Like Cyclone, Rust prevents access to uninitialized memory,
but Rust goes further than Cyclone by statically preventing dereferences of null pointers.
Unlike Cyclone, Rust does not have first class regions, but Rust also
lacks Cyclone's dynamic regions, which lessens the need for first class regions.

Cyclone later added unique pointers and a notion of borrowing. \cite{cycsafe, cycexperience}
Cyclone's version does not prevent memory leaks, which are possible both from
freeing a unique pointer that contains another live unique pointer and from
overwriting a live unique pointer. Rust statically guarantees no memory leaks in both
of these situations. Cyclone requires an explicit swap operation for using unique versions
of pointers that do not admit null values. Rust will allow any of its pointers to be null,
but guarantees that they will not be used while null. Rust also does not require explicit swaps;
Patina uses them, but that is an artifact of the model.
Cyclone considers unique pointers ``consumed'' while a borrow exists, 
whereas Rust will allow the borrowed unique pointer to be used in certain situations
(namely, reading through an immutably borrowed unique pointer is allowed).
Cyclone supports abstraction over the aliasability and kind (box versus region) of a pointer,
but Rust does not currently support any such abstraction over pointer types.

Overall, Rust and Cyclone are each more expressive in different ways.
Cyclone's dynamic regions make it much easier to specify the lifetime of
a particular heap data structure, and they allow for heap structures that
are difficult or impossible to express in Rust, such as a doubly linked list.
Rust supports far more detailed reasoning about when memory should be freed
due to its flow-sensitivity, and Rust offers safer and more convenient
usage of linear data structures, particularly with regard to freeing them.
Cyclone still has much Rust can learn from, e.g. a mechanism similar to
dynamic regions could be used to support custom allocators in Rust.

Walker and Watkins discuss how regions and linear types could be combined. \cite{regionsandlinear}
Their model supports first class regions, like Cyclone, but unlike Rust.
It also introduces the idea of linear regions and provides a mechanism for
temporarily aliasing them. This could be a fruitful ground for Rust to explore
when looking to support custom allocators.
However, their model does not support mutation, which is the source of most of the complexity
of Rust's borrow checker, and this may impact its applicability to Rust. 

Gordon et al. \cite{uniqueandrefimm} introduce a static method for ensuring data-race freedom
by enforcing that at most one mutable reference to an object exists, which is a similar task
to Rust's effort to avoid aliased, mutable memory.
Their work supports read-only references, which cannot be used to mutate, but do not forbid
mutation. Since these are by definition aliased, mutable memory, Rust has no equivalent.
However, their immutable reference is similar to Rust's immutable borrowed references,
and their isolated referece is somewhat similar to Rust's unique pointers and mutable
borrowed references. Isolated references can be coverted to writeable references and back,
which allows for behavior similar to a mutable borrowed reference. Isolated references
can also be converted into immutable references, which is analogous to immutably reborrowing
a mutably borrowed reference. Their correspondence with unique pointers is similar.
Gordon, Ernst, and Grossman \cite{relyguarantee} later propose a general notion of
rely-guarantee references, which treat aliases similar to different threads of control
and use methods from rely-guarantee program logics to ensure safety. Rust's references
can likely be encoded in this general framework.

Boyland's alias burying \cite{aliasburying} has a similar goal to Rust, i.e.
using static checks rather than destructive reads, but differs in many details.
Boyland defines a strong version of the uniqueness invariant (true uniqueness) and a weak
version (allowing borrowed aliases), and then develops a system based on maintaing
the strong invariant. Rust meets only the weak uniqueness invariant, but it also
guarantees that aliased, mutable memory never exists, which allows for similar control
over mutation as the strong uniqueness invariant. The general idea of alias burying
is to allow for aliases, but to invalidate them when a unique field is read.
Rust ensures at a unique value will not be read if (mutable) aliases exist.
Rust's borrowed references are also more first-class than Boyland's, which cannot
be stored in data structures or returned from functions.

Clarke and Wrigstad's external uniqueness \cite{externaluniqueness} has a notion
of ownership similar to Rust's. Both have recursive ownership; however, Rust uses
it for memory management rather than for access control.
Unlike Rust, unique pointers are nullified on use. The Patina model nullifies on use,
but soundness ensures it does not matter in practice.
There is also a fresh owner notion for borrowed references that accomplishes the same
thing as Rust's lifetimes, i.e. preventing escape.
Unlike Rust, Clarke and Wrigstad's borrowed references are both copyable and mutable,
which means they cannot make the same safety guarantees as Rust, i.e. no access to
uninitialized memory.
They list several options about how borrowed unique pointers can be handled, but
Rust does not cleanly fit into these categories. Rust discriminates on the manner of borrowing
and the operation to be performed to determine whether it is safe to use the borrowed
unique pointer, but Clarke and Wrigstad suggest that a system must either allow all uses
or forbid all uses.
Their model also has problems with immutable (final) variables and unique versions
of non-nullable pointers because they denote consumption via nullification and the finality
prevents that. Rust, however, has both immutable variables and all of its pointers are non-null,
but it has no issues mixing these with uniqueness. This is because Rust's ban on null pointers
is not a ban on pointers being null, but rather on pointers being used while null.
Additionally, Rust's immutable variables' usability can change if a unique value is consumed,
which allows Rust to render an immutable variable unusable thereafter.
Clarke and Wrigstad speculate that alias burying would enable them to support this combination,
which is somewhat true. Rust does manage this via static analysis, but not via alias burying.

Boyland, Noble, and Retert's capabilities for sharing \cite{capabilitiesforsharing}
provides a general framework for describing uniqueness and read-only concepts related
to pointers. However, Rust's pointers do not quite fit into their capability system.
The issue involves immutably loaned unique pointers and immutably loaned mutable borrowed
references. In Rust, both allow reading through the pointer, but do not allow reading
the pointer itself, which would require a move. The capabilities for sharing system
supports only whole object permissions, which prevents us from specifying this case
of Rust's pointers in the system.

Potanin et al. \cite{ooimmutability} survey the various ways of adding immutability
to object-oriented languages and how it impacts aliasing, including Javari, OIGJ, and Joe$_3$.
These systems usually add immutable objects and/or read-only references, but they do not
provide the no aliased, mutable memory guarantee of Rust. As discussed earlier, read-only
references are antithetical to Rust's memory safety invariant. Immutable objects are similar
to Rust's immutably borrowed references, but the OO systems often go further by allowing
immutability at the field level. Rust does not allow programmers to specify the
mutability of particular fields, but immutable borrows can provide a temporary guarantee
that is similar. Several of the OO systems have a concept of ownership, but it is primarily
about encapsulation and access control. 
Rust handles encapsulation via its module system rather than
via the type system or static analysis. As usual with OO languages, they rely on garbage
collection for memory management, which is very unlike Rust.
