\section*{L-values}

L-values in Patina are a combination of a variable and a path.
Paths are relative and specify subections of memory reachable from a L-value.

\[
\begin{array}{lccl}
\textrm{Variable} & x & & \\
\textrm{Path} & p & \bnfdef & \base \bnfalt \deref{p} \bnfalt \proj{p}{i} \bnfalt \unroll{\gt}{p} \\
\end{array}
\]

Projection ($\proj{p}{i}$) deconstructs tuples.
Unrolling ($\unroll{\gt}{p}$) deconstructs recursive types.
Dereference ($\deref{p}$) deconstructs pointers and references.
The base path ($\base$) does not deconstruct anything.

The typing judgment for paths does not present any surprises.
We use a partial map for the typing context and
the type substitution operation is the standard capture-avoiding substition.

$$ \gG : \mathrm{Variable} \to \mathrm{Type} $$

\fbox{$\tc{\gG}{\lv{x}{p}}{\gt}$}

\begin{mathpar}
\infer[PT-BASE]{\gG(x)=\gt}{\tc{\gG}{\lv{x}{\base}}{\gt}} \and
\infer[PT-DEOWN]{\tc{\gG}{\lv{x}{p}}{\own{\gt}}}{\tc{\gG}{\lv{x}{\deref{p}}}{\gt}} \and
\infer[PT-DEREF]{\tc{\gG}{\lv{x}{p}}{\tyref{\lt}{q}{\gt}}}{\tc{\gG}{\lv{x}{\deref{p}}}{\gt}} \and
\infer[PT-PROJ]{\tc{\gG}{\lv{x}{p}}{\subrec{\gt}{i}{n}}}{\tc{\gG}{\lv{x}{\proj{p}{i}}}{\gt_i}} \and
\infer[PT-UNROLL]
{\tc{\gG}{\lv{x}{p}}{\tyfix{X}{\gt}}}
{\tc{\gG}{\lv{x}{\unroll{\tyfix{X}{\gt}}{p}}}{\sub{X}{\tyfix{X}{\gt}}{\gt}}}
\end{mathpar}

Unsurprisingly, path typing is unique.
\begin{lem}[Path Type Uniqueness]
  If $\tc{\gG}{\lv{x}{p}}{\gt}$ and $\tc{\gG}{\lv{x}{p}}{\gt'}$ then $\gt = \gt' $.
\end{lem}

\begin{proof}[Path Type Uniqueness]
  We will use induction on the derivation of $\tc{\gG}{\lv{x}{p}}{\gt}$.
  \begin{itemize}
    \item[\textsc{PT-BASE}] Then $p = \base$.

      By inversion, $\gG(x)=\gt$.
      
      There is only one possible rule (\textsc{PT-BASE}) for 
      deriving $\tc{\gG}{\lv{x}{\base}}{\gt'}$ 
      
      Ergo, by inversion, $\gG(x)=\gt'$.

      Thus, $\gt = \gt'$.
    \item[\textsc{PT-DEOWN}] Then $p = \deref{p'}$.

      By inversion, $\tc{\gG}{\lv{x}{p'}}{\own{\gt}}$.

      There are two possible rules for deriving $\tc{\gG}{\lv{x}{\deref{p'}}}{\gt'}$.
      \begin{itemize}
	\item[\textsc{PT-DEOWN}]
	  By inversion, $\tc{\gG}{\lv{x}{p'}}{\own{\gt'}}$.

	  By induction $\own{\gt} =\ \own{\gt'}$.

	  Ergo $\gt = \gt'$.
	\item[\textsc{PT-DEREF}]
	  By inversion, $\tc{\gG}{\lv{x}{p'}}{\tyref{\lt}{q}{\gt'}}$.

	  By induction $\own{\gt} = \tyref{\lt}{q}{\gt'}$, a contradiction.

	  Thus, this case is impossible.
      \end{itemize}
    \item[\textsc{PT-DEREF}] Then $p = \deref{p'}$.

      Similar to the \textsc{PT-DEOWN} case, 
      but swapping the roles of \textsc{PT-DEOWN} and \textsc{PT-DEREF}.
    \item[\textsc{PT-PROJ}] Then $p = \proj{p'}{i}$ and $\gt = \gt_i$.

      By inversion, $\tc{\gG}{\lv{x}{p'}}{\subrec{\gt}{i}{n}}$.

      There is only one rule (\textsc{PT-PROJ}) for deriving $\tc{\gG}{\lv{x}{\proj{p'}{i}}}{\gt'}$.

      Thus, by inversion, $\gt' = \gt'_i$ and $\tc{\gG}{\lv{x}{p'}}{\subrec{\gt'}{i}{n'}}$.

      By induction, $\subrec{\gt}{i}{n} = \subrec{\gt'}{i}{n'}$.

      Ergo $n = n'$ and $\gt_i = \gt'_i$.
    \item[\textsc{PT-UNROLL}] 
      Then $p = \unroll{\tyfix{X}{\gt_0}}{p'}$ and $\gt = \sub{X}{\tyfix{X}{\gt_0}}{\gt_0}$.

      There is only one rule (\textsc{PT-UNROLL}) for deriving
      $\tc{\gG}{\lv{x}{\unroll{\tyfix{X}{\gt_0}}{p'}}}{\gt'}$.

      Thus, by inversion, $\gt' = \sub{X}{\tyfix{X}{\gt_0}}{\gt_0}$.

      Ergo $\gt = \sub{X}{\tyfix{X}{\gt_0}}{\gt_0} = \gt'$.
  \end{itemize}
\end{proof}

\section*{Runtime Memory}

\subsection*{Representation and Addressing}

To accurately model Rust's memory usage, Patina restricts
the contents of a memory cell to void data, an integer, or a pointer to another cell.
Tuples and recursive types have no physical memory presence (beyond contiguity for tuples).
The memory representation of a variant is a pair of a cell for the discriminant
and whatever memory is necessary to store the payload.

We could model this by a map from addresses to memory cell values,
but two issues make this inconvenient: the need for address arithmetic
and non-unique typing. However, we can add a little extra structure to
our model and eliminate these two issues. We wrap the cells inside
layouts describing the type structure overlaying memory.

We also separate plain pointer cells into owned cells and reference cells.
This is mostly useful for providing just enough type information about the pointer
for memory operation purposes. We will explain how we address memory in a moment,
so we use a placeholder for now.

\[
\begin{array}{lccl}
\textrm{Integer} & z & & \\
\textrm{Address} & \rho & & \textrm{a placeholder} \\
\textrm{Cell} & c & \bnfdef & \void \bnfalt z \bnfalt \own{\rho} \bnfalt \Ref{q~\rho} \\
\textrm{Layout} & l & \bnfdef & c \bnfalt \varval{c}{l} \bnfalt 
			       \subrec{l}{i}{n} \bnfalt \roll{\gt}{l} \\
\end{array}
\]

Due to the extra structure from layouts, addressing memory now requires
more than simple labels. Instead we use a runtime analogue of variables and paths.
Allocations are chunks of memory allocated and freed atomically.
They correspond to either variables or heap allocations.
Routes provide relative specification into layouts similar to paths with two key differences.

\[
\begin{array}{lccl}
\textrm{Allocation} & \ga & & \\
\textrm{Route} & r & \bnfdef & \base \bnfalt \proj{r}{i} \bnfalt \pay{r} \bnfalt \unroll{\gt}{r} \\
\end{array}
\]

The $\base$ route, projection, and unrolling are effectively identical to their path equivalents.
The $\pay{r}$ route refers to the payload $l$ in a variant $\varval{c}{l}$.
This is primarily used for match-by-reference.
Unlike paths, there is no dereference route.
This forces any pointer following into path evaluation (into routes)
rather than doing so while reading memory at a route.
The address placeholder from before is simply a pair of an allocation label and a route.
That is:

\[
\begin{array}{lccl}
\textrm{Integer} & z & & \\
\textrm{Allocation} & \ga & & \\
\textrm{Route} & r & \bnfdef & \base \bnfalt \proj{r}{i} \bnfalt \pay{r} \bnfalt \unroll{\gt}{r} \\
\textrm{Cell} & c & \bnfdef & \void \bnfalt z \bnfalt 
			      \own{\addr{\ga}{r}} \bnfalt \refval{q}{\addr{\ga}{r}} \\
\textrm{Layout} & l & \bnfdef & c \bnfalt \varval{c}{l} \bnfalt 
			       \subrec{l}{i}{n} \bnfalt \roll{\gt}{l} \\
\end{array}
\]

\subsection*{Reading}

Reading a layout from a route in memory is a straightforward operation.
We model the heap as a partial map from allocations to layouts.
Routes and layouts interact as you would expect.

$$ H : \mathrm{Allocation} \to \mathrm{Layout} $$

\fbox{$\Read{H}{\addr{\ga}{r}}{l}$}

\begin{mathpar}
\infer[RD-BASE]{H(\ga)=l}{\Read{H}{\addr{\ga}{\base}}{l}} \and
\infer[RD-PROJ]
  {\Read{H}{\addr{\ga}{r}}{\subrec{l}{i}{n}}}
  {\Read{H}{\addr{\ga}{\proj{r}{i}}}{l_i}} \and
\infer[RD-PAY]{\Read{H}{\addr{\ga}{r}}{\varval{c}{l}}}{\Read{H}{\addr{\ga}{\pay{r}}}{l}} \and
\infer[RD-UNROLL]{\Read{H}{\addr{\ga}{r}}{\roll{\gt'}{l}}}{\Read{H}{\addr{\ga}{\unroll{\gt}{r}}}{l}}
\end{mathpar}

As one would expect of a read operation, it's result is unique.

\begin{lem}[Read Uniqueness]
  If $\Read{H}{\addr{\ga}{r}}{l}$ and $\Read{H}{\addr{\ga}{r}}{l'}$, then $l = l'$.
\end{lem}

\begin{proof}[Read Uniqueness]
  We will induct on the derivation of $\Read{H}{\addr{\ga}{r}}{l}$.
  \begin{itemize}
    \item[\textsc{RD-BASE}] Then $r = \base$.

      By inversion, $H(\ga)=l$.

      There is only one rule (\textsc{RD-BASE}) for deriving $\Read{H}{\addr{\ga}{\base}}{l'}$.

      Thus, by inversion, $H(\ga)=l'$.

      Ergo, $l = l'$.
    \item[\textsc{RD-PROJ}] Then $r = \proj{r'}{i}$ and $l = l_i$.

      By inversion, $\Read{H}{\addr{\ga}{r'}}{\subrec{l}{i}{n}}$.

      There is only one rule (\textsc{RD-PROJ}) for
      deriving $\Read{H}{\addr{\ga}{\proj{r'}{i}}}{l'}$.

      Thus, by inversion, $\Read{H}{\addr{\ga}{r'}}{\subrec{l'}{i}{n'}}$.

      By induction, $\subrec{l}{i}{n} = \subrec{l'}{i}{n'}$.

      Ergo, $n = n'$ and $l_i = l'_i$.
    \item[\textsc{RD-PAY}] Then $r = \pay{r'}$.

      By inversion, $\Read{H}{\addr{\ga}{r'}}{\varval{c}{l}}$.

      There is only one rule (\textsc{RD-PAY}) for deriving $\Read{H}{\addr{\ga}{\pay{r'}}}{l'}$.

      Thus, by inversion, $\Read{H}{\addr{\ga}{r'}}{\varval{c'}{l'}}$.

      By induction, $\varval{c}{l} = \varval{c'}{l'}$.

      Ergo, $c = c'$ and $l = l'$.
    \item[\textsc{RD-UNROLL}] Then $r = \unroll{\gt}{r'}$.

      By inversion, $\Read{H}{\addr{\ga}{r'}}{\roll{\gt'}{l}}$.

      There is only one rule (\textsc{RD-UNROLL}) for
      deriving $\Read{H}{\addr{\ga}{\unroll{\gt}{r'}}}{l'}$.

      Thus, by inversion, $\Read{H}{\addr{\ga}{r'}}{\roll{\gt''}{l'}}$.

      By induction, $\roll{\gt'}{l} = \roll{\gt''}{l'}$.

      Ergo, $\gt' = \gt''$ and $l = l'$.
  \end{itemize}
\end{proof}

\section*{Path Evaluation}

Now that we can read memory, we can define path evaluation.
The only actual work of path evaluation is following the dereferences of pointers
to produce a route. In order to connect variables to runtime allocations, we use
a partial map tracking the allocation labels of variables.

$$ V : \mathrm{Variable} \to \mathrm{Allocation} $$

\fbox{$\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}$}

\begin{mathpar}
\infer[PE-BASE]{V(x)=\ga}{\ev{V;H}{\lv{x}{\base}}{\addr{\ga}{\base}}} \and
\infer[PE-DEOWN]
  {\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}} \\ \Read{H}{\addr{\ga}{r}}{\own{\addr{\ga'}{r'}}}}
  {\ev{V;H}{\lv{x}{\deref{p}}}{\addr{\ga'}{r'}}} \and
\infer[PE-DEREF]
  {\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}} \\ \Read{H}{\addr{\ga}{r}}{\refval{q}{\addr{\ga'}{r'}}}}
  {\ev{V;H}{\lv{x}{\deref{p}}}{\addr{\ga'}{r'}}} \and
\infer[PE-PROJ]
  {\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}}
  {\ev{V;H}{\lv{x}{\proj{p}{i}}}{\addr{\ga}{\proj{r}{i}}}} \and
\infer[PE-UNROLL]
  {\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}}
  {\ev{V;H}{\lv{x}{\unroll{\gt}{p}}}{\addr{\ga}{\unroll{\gt}{r}}}}
\end{mathpar}

With path typing and evaluation now defined, we would like to prove progress
and preservation for them. Preservation will require we define typing for
runtime data (routes, cells, and layouts), which involves a slight bit of trickery
around variant discriminants and the payload route.

Progress will require a way to guarantee that the necessary \textsc{read}s 
can be completed, i.e. any pointers we need to dereference are in fact initialized
(a property we call \emph{shallow initialization}).
We will accomplish this by using a kind of shadow heap, which will simply track
initialization rather than values.
This will require an analogue of \textsc{read} that extracts the initialization
data for a path, a proof that this operation preserves types 
(which itselfs requires typing for this shadow heap),
a coherence check to ensure the shadow heap models the runtime heap,
and a proof that a shallowly initialized path evaluates to a readable route.

\section*{Runtime Typing}
\subsection*{Route Typing}
Typing routes is much like typing paths; however, the $\pay{r}$ route requires
special attention. Since this route points to the payload of a variant,
its type depends upon the value of the discriminant of the variant.
We handle this with an additional context that records the discriminant value
of a variant stored at a route.

$$ \gS : \mathrm{Allocation} \to \mathrm{Type}$$
$$ \gY : \mathrm{Allocation} \times \mathrm{Route} \to \mathrm{Integer} $$

\fbox{$\tc{\gS;\gY}{\addr{\ga}{r}}{\gt} $}

\begin{mathpar}
\infer[RT-BASE]{\gS(\ga)=\gt}{\tc{\gS;\gY}{\addr{\ga}{\base}}{\gt}}
\and
\infer[RT-PROJ]
  {\tc{\gS;\gY}{\addr{\ga}{r}}{\subrec{\gt}{i}{n}}}
  {\tc{\gS;\gY}{\addr{\ga}{\proj{r}{i}}}{\gt_i}}
\and
\infer[RT-PAY]
  {\gY(\ga,r)=i \\ \tc{\gS;\gY}{\addr{\ga}{r}}{\subvar{\gt}{i}{n}}}
  {\tc{\gS;\gY}{\addr{\ga}{\pay{r}}}{\gt_i}}
\and
\infer[RT-UNROLL]
  {\tc{\gS;\gY}{\addr{\ga}{r}}{\tyfix{X}{\gt}}}
  {\tc{\gS;\gY}{\addr{\ga}{\unroll{\tyfix{X}{\gt}}{r}}}{\sub{X}{\tyfix{X}{\gt}}{\gt}}}
\end{mathpar}

\subsection*{Layout and Cell Typing}
Typing for layouts and cells is what you would expect.
However, we restrict the type of $\void$ to the possible types for other
kinds of cells, i.e. $\tyint$, unique pointers, and borrowed references.
This means that multi-cell layout types (variants, tuples, and recursive types) imply
a non-$\void$ value.
\newline

\fbox{$\tc{\gS;\gY}{l}{\gt}$}

\begin{mathpar}
\infer[LT-VOIDINT]
{ }
{\tc{\gS;\gY}{\void}{\tyint}}
\and
\infer[LT-VOIDOWN]
{ }
{\tc{\gS;\gY}{\void}{\own{\gt}}}
\and
\infer[LT-VOIDREF]
{ }
{\tc{\gS;\gY}{\void}{\tyref{\lt}{q}{\gt}}}
\and
\infer[LT-INT]
{ }
{\tc{\gS;\gY}{z}{\tyint}}
\and
\infer[LT-OWN]
{\tc{\gS;\gY}{\addr{\ga}{r}}{\gt}}
{\tc{\gS;\gY}{\own{\addr{\ga}{r}}}{\own{\gt}}}
\and
\infer[LT-REF]
{\tc{\gS;\gY}{\addr{\ga}{r}}{\gt}}
{\tc{\gS;\gY}{\refval{q}{\addr{\ga}{r}}}{\tyref{\lt}{q}{\gt}}}
\and
\infer[LT-VOIDVAR]
{ }
{\tc{\gS;\gY}{\varval{\void}{\void}}{\subvar{\gt}{i}{n}}}
\and
\infer[LT-VAR]
{\tc{\gS;\gY}{l}{\gt_i}}
{\tc{\gS;\gY}{\varval{i}{l}}{\subvar{\gt}{i}{n}}}
\and
\infer[LT-REC]
{\forall i.~\tc{\gS;\gY}{l_i}{\gt_i}}
{\tc{\gS;\gY}{\subrec{l}{i}{n}}{\subrec{\gt}{i}{n}}}
\and
\infer[LT-ROLL]
{\tc{\gS;\gY}{l}{\sub{X}{\tyfix{X}{\gt}}{\gt}}}
{\tc{\gS;\gY}{\roll{\tyfix{X}{\gt}}{l}}{\tyfix{X}{\gt}}}
\end{mathpar}

\subsection*{Heap Well-Formedness}
With runtime typing now in hand, we can say what it means for the heap to be well-formed.
We say a heap $H$ is described by a heap type $\gS$ and a discriminant context $\gY$ if
every allocation in $H$ has the type assigned to it by $\gS$
and $\gY$ correctly records the discrimiants of all the variants in $H$.
Formally,

\begin{mathpar}
\mprset{flushleft}
\infer
{ 
\dom{H} = \dom{\gS} \\\\
\forall \ga \in \dom(\gS).~\gS(\ga)~\textrm{closed} \\\\
\forall \ga \in \dom{H}.~\tc{\gS;\gY}{H(\ga)}{\gS(\ga)} \\\\
\forall (\ga,r) \in \dom{\gY}.~\Read{H}{\addr{\ga}{r}}{\varval{\gY(\ga,r)}{l}}
}
{\tc{}{H}{\gS;\gY}}
\end{mathpar}

\section*{Read Safety}
We are now in position to prove that our read operation is safe.
That is, if the heap is well formed and a route is has some type,
then we can read some layout at that route and that layout has that same type.

\begin{lem}[Read Safety]
If $\tc{}{H}{\gS;\gY}$ and $\tc{\gS;\gY}{\addr{\ga}{r}}{\gt}$,
then there is a layout $l$ such that $\Read{H}{\addr{\ga}{r}}{l}$ and $\tc{\gS;\gY}{l}{\gt}$.
\end{lem}

\begin{proof}[Read Safety]
  We will use induction on the derivation of $\tc{\gS;\gY}{\addr{\ga}{r}}{\gt}$.
  \begin{itemize}
    \item[\textsc{RT-BASE}] Then $r = \base$.

      By inversion, $\gS(\ga)=\gt$.

      From $\tc{}{H}{\gS;\gY}$, we know that $\dom{H}=\dom{\gS}$.
      Thus, $\exists l.~H(\ga)=l$.

      Then by \textsc{RD-BASE}, we have $\Read{H}{\addr{\ga}{\base}}{l}$.

      Again from $\tc{}{H}{\gS;\gY}$, we know that $\tc{\gS;\gY}{H(\ga)}{\gS(\ga)}$,
      which is just $\tc{\gS;\gY}{l}{\gt}$ as required.
    \item[\textsc{RT-PROJ}] Then $r = \proj{r'}{i}$ and $\gt = \gt_i$.

      By inversion, $\tc{\gS;\gY}{\addr{\ga}{r'}}{\subrec{\gt}{i}{n}}$.

      By induction, $\Read{H}{\addr{\ga}{r'}}{l}$
      and $\tc{\gS;\gY}{l}{\subrec{\gt}{i}{n}}$ for some $l$.

      There is only one rule (\textsc{LT-REC}) for deriving $\tc{\gS;\gY}{l}{\subrec{\gt}{i}{n}}$.

      Thus, by inversion, $l = \subrec{l'}{j}{n}$ 
      and $\forall j.~\tc{\gS;\gY}{l'_j}{\gt_j}$.
      Specifically, $\tc{\gS;\gY}{l'_i}{\gt_i}$.

      Then by \textsc{RD-PROJ}, we have $\Read{H}{\addr{\ga}{\proj{r'}{i}}}{l'_i}$.
    \item[\textsc{RT-PAY}] Then $r = \pay{r'}$ and $\gt = \gt_i$.

      By inversion, $\gY(\ga,r')=i$ and $\tc{\gS;\gY}{\addr{\ga}{r'}}{\subvar{\gt}{i}{n}}$.

      By induction, $\Read{H}{\addr{\ga}{r'}}{l}$
      and $\tc{\gS;\gY}{l}{\subvar{\gt}{i}{n}}$.

      From $\tc{}{H}{\gS;\gY}$, we know that because $\gY(\ga,r')=i$
      it follows that $\Read{H}{\addr{\ga}{r'}}{\varval{i}{l'}}$ for some $l'$.

      By Read Uniqueness, we know that $l = \varval{i}{l'}$.

      There is only one rule (\textsc{LT-VAR}) for deriving 
      $\tc{\gS;\gY}{\varval{i}{l'}}{\subvar{\gt}{i}{n}}$.

      Thus, by inversion, $\tc{\gS;\gY}{l'}{\gt_i}$.

      Then by \textsc{RD-PAY}, we have $\Read{H}{\addr{\ga}{\pay{r'}}}{l'}$.
    \item[\textsc{RT-UNROLL}] 
      Then $r = \unroll{\tyfix{X}{\gt'}}{r'}$ and $\gt = \sub{X}{\tyfix{X}{\gt'}}{\gt'}$.

      By inversion, $\tc{\gS;\gY}{\addr{\ga}{r'}}{\tyfix{X}{\gt'}}$.

      By induction, $\Read{H}{\addr{\ga}{r'}}{l}$ 
      and $\tc{\gS;\gY}{l}{\tyfix{X}{\gt'}}$ for some $l$.

      There is only one rule (\textsc{LT-ROLL}) for deriving $\tc{\gS;\gY}{l}{\tyfix{X}{\gt'}}$.

      Thus, by inversion, $l = \roll{\tyfix{X}{\gt'}}{l'}$
      and $\tc{\gS;\gY}{l'}{\sub{X}{\tyfix{X}{\gt'}}{\gt'}}$.

      Then by \textsc{RD-UNROLL}, we have
      $\Read{H}{\addr{\ga}{\unroll{\tyfix{X}{\gt'}}{r'}}}{l'}$.
  \end{itemize}
\end{proof}

\section*{Path Type Preservation}
The final piece we need for preservation is how to relate the typing context $\gG$,
the variable map $V$, and the heap type $\gS$. This is simply the requirement that
the map $V$ preserves typing.

\begin{mathpar}
  \infer
  {\forall x \in \dom{\gG}.~\gG(x)=\gS(V(x))}
  {\gG;V\vdash\gS}
\end{mathpar}

Finally, we can state and prove path type preservation.
Under well-formed heap and contexts, typed paths evaluate to routes of the same type.

\begin{lem}[Path Type Preservation]
  If $\tc{}{H}{\gS;\gY}$, $\gG;V\vdash\gS$, $\tc{\gG}{\lv{x}{p}}{\gt}$,
  and $\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}$, then $\tc{\gS;\gY}{\addr{\ga}{r}}{\gt}$.
\end{lem}

\begin{proof}[Path Type Preservation]
  We will use induction on the derivation of $\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}$.
  \begin{itemize}
    \item[PE-BASE] Then $p = \base$ and $r = \base$.

      By inversion, $V(x)=\ga$.

      There is only one rule (\textsc{PT-BASE}) for deriving $\tc{\gG}{\lv{x}{\base}}{\gt}$.

      Thus, by inversion, we have $\gG(x)=\gt$.

      From $\gG;V\vdash\gS$, we know $\gG(x)=\gS(V(x))$. Thus, $\gt=\gS(\ga)$.

      Then by \textsc{RT-BASE}, we have $\tc{\gS;\gY}{\addr{\ga}{\base}}{\gt}$.
    \item[PE-DEOWN] Then $p = \deref{p'}$.

      By inversion, $\ev{V;H}{\lv{x}{p'}}{\addr{\ga'}{r'}}$
      and $\Read{H}{\addr{\ga'}{r'}}{\own{\addr{\ga}{r}}}$.

      There are two possible rules for deriving $\tc{\gG}{\lv{x}{\deref{p'}}}{\gt}$.
      \begin{itemize}
	\item[PT-DEOWN]

	  By inversion, $\tc{\gG}{\lv{x}{p'}}{\own{\gt}}$.

	  By induction, $\tc{\gS;\gY}{\addr{\ga'}{r'}}{\own{\gt}}$.

	  By Read Safety, we have $\Read{H}{\addr{\ga'}{r'}}{l}$
	  and $\tc{\gS;\gY}{l}{\own{\gt}}$ for some $l$.

	  By Read Uniqueness, we have $l =\ \own{\addr{\ga}{r}}$.

	  There is only one rule (\textsc{LT-OWN}) for deriving 
	  $\tc{\gS;\gY}{\own{\addr{\ga}{r}}}{\own{\gt}}$.

	  Thus, by inversion, $\tc{\gS;\gY}{\addr{\ga}{r}}{\gt}$.
	\item[PT-DEREF]

	  By inversion, $\tc{\gG}{\lv{x}{p'}}{\tyref{\lt}{q}{\gt}}$.

	  By induction, $\tc{\gS;\gY}{\addr{\ga'}{r'}}{\tyref{\lt}{q}{\gt}}$.

	  By Read Safety, we have $\Read{H}{\addr{\ga'}{r'}}{l}$
	  and $\tc{\gS;\gY}{l}{\tyref{\lt}{q}{\gt}}$ for some $l$.

	  By Read Uniqueness, we have $l =\ \own{\addr{\ga}{r}}$.

	  There are no rules for deriving
	  $\tc{\gS;\gY}{\own{\addr{\ga}{r}}}{\tyref{\lt}{q}{\gt}}$.

	  Thus, by inversion, this case is impossible.
      \end{itemize}
    \item[PE-DEREF] 
      Similar to the \textsc{PE-DEOWN} case, but switching the roles of
      \textsc{PT-DEOWN} and \textsc{PT-DEREF}.
    \item[PE-PROJ] Then $p = \proj{p'}{i}$ and $r = \proj{r'}{i}$.

      By inversion, $\ev{V;H}{\lv{x}{p'}}{\addr{\ga}{r'}}$.

      There is only one rule (\textsc{PT-PROJ}) for deriving $\tc{\gG}{\lv{x}{\proj{p'}{i}}}{\gt}$.

      Thus, by inversion, we have $\gt = \gt_i$ and $\tc{\gG}{\lv{x}{p'}}{\subrec{\gt}{i}{n}}$.

      By induction, we have $\tc{\gS;\gY}{\addr{\ga}{r'}}{\subrec{\gt}{i}{n}}$.

      Then by \textsc{RT-PROJ}, we have $\tc{\gS;\gY}{\addr{\ga}{\proj{r'}{i}}}{\gt_i}$.
    \item[PE-UNROLL] Then $p = \unroll{\gt'}{p'}$ and $r = \unroll{\gt'}{r'}$.

      By inversion, $\ev{V;H}{\lv{x}{p'}}{\addr{\ga}{r'}}$.

      There is only one rule (\textsc{PT-UNROLL}) for deriving
      $\tc{\gG}{\lv{x}{\unroll{\gt'}{p'}}}{\gt}$.

      Thus, by inversion, we have $\gt' = \tyfix{X}{\gt''}$,
      $\gt = \sub{X}{\tyfix{X}{\gt''}}{\gt''}$, and
      $\tc{\gG}{\lv{x}{p'}}{\tyfix{X}{\gt''}}$.

      By induction, we have $\tc{\gS;\gY}{\addr{\ga}{r'}}{\tyfix{X}{\gt''}}$.

      Then by \textsc{RT-UNROLL}, we have
      $\tc{\gS;\gY}{\addr{\ga}{\unroll{\tyfix{X}{\gt''}}{r'}}}{\sub{X}{\tyfix{X}{\gt''}}{\gt''}}$.
  \end{itemize}
\end{proof}

\section*{Tracking Initialization}
To properly type check Patina, we need to know which paths point to initialized memory
and which do not. This is important for ensuring we never use uninitialized memory and
that we correctly free heap memory.
We will accomplish this by creating a shadow heap.
Instead of tracking actual values, we will simply track whether a cell is initialized.
Paths will serve the same function for this shadow heap as routes do for the real heap.

\[
\begin{array}{lccl}
\textrm{Hole} & h & \bnfdef & \uninit \bnfalt \tyint \bnfalt \own{\gs} 
				      \bnfalt \refval{q}{\gt} \bnfalt \subvar{\gt}{i}{n} \\
\textrm{Shadow} & \gs & \bnfdef & h \bnfalt \subrec{\gs}{i}{n} \bnfalt \roll{\gt}{\gs} \\
\end{array}
\]

Since shadows and holes are supposed to be a shadow of the heap,
it is unsurprising that they are very similar to layouts and cells.
However, there are a few key differences.
First, variants are considered an atomic value (and thus a hole) rather than
a structure. This is because the discrimiant and payload of a variant always
share the same initialization state.
Second, while the pointer cells contain routes, the pointer holes do not
contain paths (the analogue of routes).
For references, there is no need because references always point to fully initialized things.
Therefore, the reference hole simply records the type of the reference.
For unique pointers, there is no path that could possibly be used
(otherwise the pointer would not be unique).
Therefore, the unique pointer hole records the shadow of the pointed-to heap memory.

\section*{Checking Shallow Initialization}
We will need an analogue of \textsc{read} for our shadow heap for the
simple purpose of extracting the shadow at a path in the same way we
need to extract the layout at a route from the heap.
However, this analogue also serves as a very useful property checker:
any dereferences in the path are dereferences of initialized memory.
This property, called \emph{shallow initialization} is exactly what we need
for path progress. A shallowly initialized path can successfully dereference
all the pointers necessary to evaluate to a route.
For this reason, we call this operation \textsc{shallow}.

To support dereferencing references, we need to construct a shape from the referenced type.
We do this with the \textsc{init} function.

$$ $$

\fbox{$\textsc{init} : \textrm{Type} \to \textrm{Shadow}$}

\[
\begin{array}{lcl}
\initShadow{\tyint} &=& \tyint \\
\initShadow{\own{\gt}} &=& \own{\initShadow{\gt}} \\
\initShadow{\tyref{\lt}{q}{\gt}} &=& \refval{q}{\gt} \\
\initShadow{\subrec{\gt}{i}{n}} &=& [\initShadow{\gt_i}]_{i \in \{1\ldots n\}} \\
\initShadow{\subvar{\gt}{i}{n}} &=& \subvar{\gt}{i}{n} \\
\initShadow{\tyfix{X}{\gt}} &=& \roll{\tyfix{X}{\gt}}{\initShadow{\sub{X}{\tyfix{X}{\gt}}{\gt}}} \\
\end{array}
\]

We also need a new context recording the shadows of stack variables.

$$ \gU : \textrm{Variable} \to \textrm{Shadow} $$

\fbox{$\shallow{\gU}{\lv{x}{p}}{\gs}$}

\begin{mathpar}
\infer[SI-BASE]
{\gU(x)=\gs}
{\shallow{\gU}{\lv{x}{\base}}{\gs}}
\and
\infer[SI-DEOWN]
{\shallow{\gU}{\lv{x}{p}}{\own{\gs}}}
{\shallow{\gU}{\lv{x}{\deref{p}}}{\gs}}
\and
\infer[SI-DEREF]
{\shallow{\gU}{\lv{x}{p}}{\refval{q}{\gt}} \\ \initShadow{\gt}=\gs}
{\shallow{\gU}{\lv{x}{\deref{p}}}{\gs}}
\and
\infer[SI-PROJ]
{\shallow{\gU}{\lv{x}{p}}{\subrec{\gs}{i}{n}}}
{\shallow{\gU}{\lv{x}{\proj{p}{i}}}{\gs_i}}
\and
\infer[SI-UNROLL]
{\shallow{\gU}{\lv{x}{p}}{\roll{\gt'}{\gs}}}
{\shallow{\gU}{\lv{x}{\unroll{\gt}{p}}}{\gs}}
\end{mathpar}

\section*{Shadow Typing}
We need to ensure that the shadows assigned to variables are consistent with the types
assigned to variables, i.e. we want to avoid situations like
$\gG(x)=\tyint$ and $\gU(x)=\refval{\qimm}{\tyint}$.
We can easily do this by defining a typing judgement for shadows and
defining a well-formedness condition for $\gU$ that ensures it is consistent with $\gG$.
Similar to typing for layouts, $\uninit$ can only have types that other holes can have.
\newline

\fbox{$\tc{}{\gs}{\gt}$}

\begin{mathpar}
\infer[ST-UNINT]
{ }
{\tc{}{\uninit}{\tyint}}
\and
\infer[ST-UNOWN]
{ }
{\tc{}{\uninit}{\own{\gt}}}
\and
\infer[ST-UNREF]
{ }
{\tc{}{\uninit}{\tyref{\lt}{q}{\gt}}}
\and
\infer[ST-UNVAR]
{ }
{\tc{}{\uninit}{\subvar{\gt}{i}{n}}}
\and
\infer[ST-INT]
{ }
{\tc{}{\tyint}{\tyint}}
\and
\infer[ST-OWN]
{\tc{}{\gs}{\gt}}
{\tc{}{\own{\gs}}{\own{\gt}}}
\and
\infer[ST-REF]
{ }
{\tc{}{\refval{q}{\gt}}{\tyref{\lt}{q}{\gt}}}
\and
\infer[ST-VAR]
{ }
{\tc{}{\subvar{\gt}{i}{n}}{\subvar{\gt}{i}{n}}}
\and
\infer[ST-REC]
{\forall i.~\tc{}{\gs_i}{\gt_i}}
{\tc{}{\subrec{\gs}{i}{n}}{\subrec{\gt}{i}{n}}}
\and
\infer[ST-ROLL]
{\tc{}{\gs}{\sub{X}{\tyfix{X}{\gt}}{\gt}}}
{\tc{}{\roll{\tyfix{X}{\gt}}{\gs}}{\tyfix{X}{\gt}}}
\end{mathpar}

\begin{mathpar}
\mprset{flushleft}
\infer
{ 
\dom{\gG}=\dom{\gU} \\\\
\forall x \in \dom{\gG}.~\gG(x)~\textrm{closed} \\\\
\forall x \in \dom{\gG}.~\tc{}{\gU(x)}{\gG(x)}
}
{\tc{}{\gU}{\gG}}
\end{mathpar}

\subsection*{Shallow Preserves Types}
Just as with \textsc{read}, \textsc{shallow} preserves types.

\begin{lem}[Shallow Type Preservation]
  If $\tc{}{\gU}{\gG}$, $\tc{\gG}{\lv{x}{p}}{\gt}$, and $\shallow{\gU}{\lv{x}{p}}{\gs}$
  then $\tc{}{\gs}{\gt}$.
\end{lem}

\begin{proof}[Shallow Type Preservation]
  TODO copy over and prettify
\end{proof}

\section*{Shadow Coherence}
Of course, we also need to check that our shadow heap correctly models
the actual heap. For the most part, it is exactly the relation you would expect.
We require two auxiliary judgments to check for certain initialization states of layouts.
The $\textsc{init}(H,l)$ judgment checks that $l$ is \emph{fully initialized}, 
i.e. $\void$ does not occur in any memory reachable from $l$.
These layouts are safe to use because we cannot access uninitialized memory from them.
The $\textsc{droppable}(l)$ judgment checks that $l$ owns no initialized heap memory,
i.e. $\own{\addr{\ga}{r}}$ is not reachable from $l$ except through references.
These layouts are safe to deallocate because we cannot orphan heap memory by doing so.
\newline

\fbox{$\tc{H}{l}{\gs}$}

\begin{mathpar}
\infer[LS-VOID]
{ }
{\tc{H}{\void}{\uninit}}
\and
\infer[LS-INT]
{ }
{\tc{H}{z}{\tyint}}
\and
\infer[LS-OWN]
{\Read{H}{\addr{\ga}{r}}{l} \\ \tc{H}{l}{\gs}}
{\tc{H}{\own{\addr{\ga}{r}}}{\own{\gs}}}
\and
\infer[LS-REF]
{\Read{H}{\addr{\ga}{r}}{l} \\ \textsc{init}(H,l)}
{\tc{H}{\refval{q}{\addr{\ga}{r}}}{\refval{q}{\gt}}}
\and
\infer[LS-VOIDVAR]
{ }
{\tc{H}{\varval{\void}{\void}}{\uninit}}
\and
\infer[LS-DROPVAR]
{\textsc{droppable}(l)}
{\tc{H}{\varval{i}{l}}{\uninit}}
\and
\infer[LS-VAR]
{\textsc{init}(H,l)}
{\tc{H}{\varval{i}{l}}{\subvar{\gt}{i}{n}}}
\and
\infer[LS-REC]
{\forall i.~\tc{H}{l_i}{\gs_i}}
{\tc{H}{\subrec{l}{i}{n}}{\subrec{\gs}{i}{n}}}
\and
\infer[LS-ROLL]
{\tc{H}{l}{\gs}}
{\tc{H}{\roll{\tyfix{X}{\gt}}{l}}{\roll{\tyfix{X}{\gt}}{\gs}}}
\end{mathpar}

We formally require our heap to match our shadow heap with the following:

\begin{mathpar}
\mprset{flushleft}
\infer
{ 
\dom{V}=\dom{\gU} \\\\
\forall x \in \dom{V}.~\tc{H}{H(V(x))}{\gU(x)}
}
{\tc{V}{H}{\gU}}
\end{mathpar}

\section*{Shadow Preservation}
We need to tie the shadow of a shallowly initialized path
to the layout read from a route when the path evaluated to the route.
This will let us carry guarantees from paths and shadows over to routes and layouts.

\begin{lem}[Shadow Preservation]
  If $\tc{V}{H}{\gU}$, $\shallow{\gU}{\lv{x}{p}}{\gs}$, 
  $\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}$ , and $\Read{H}{\addr{\ga}{r}}{l}$
  then $\tc{H}{l}{\gs}$.
\end{lem}

\begin{proof}[Shadow Preservation]
  TODO copy and prettify
\end{proof}

\section*{Path Progress}
Finally, we have all we need to proof path progress.
Assuming all our contexts and the heap are well-formed,
then a shallowly initialized, well-typed path can evaluate to some route.
We can then rely to path preservation to show that route has the same type as the path.
Read safety then lets us show that we can read a layout at that route
and that it has the same type.

\begin{lem}[Path Progress]
  If $\tc{}{H}{\gS;\gY}$, $\gG;V\vdash\gS$, $\tc{}{\gU}{\gG}$, $\tc{V}{H}{\gU}$,
  $\tc{\gG}{\lv{x}{p}}{\gt}$, and $\shallow{\gU}{\lv{x}{p}}{\gs}$
  then there is some $\addr{\ga}{r}$ such that $\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}$.
\end{lem}

\begin{proof}[Path Progress]
  TODO copy and prettify
\end{proof}
