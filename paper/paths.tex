\section*{L-values}

L-values in Patina are a combination of a variable and a path.
Paths are relative and specify subections of memory reachable from a L-value.
Projection ($\proj{p}{i}$) deconstructs tuples.
Unrolling ($\unroll{\gt}{p}$) deconstructs recursive types.
Dereference ($\deref{p}$) deconstructs pointers and references.
The base path ($\base$) does not deconstruct anything.

\[
\begin{array}{lccl}
\textrm{Variable} & x & & \\
\textrm{Path} & p & \bnfdef & \base \bnfalt \deref{p} \bnfalt \proj{p}{i} \bnfalt \unroll{\gt}{p} \\
\end{array}
\]

The L-value layer of Patina has two core operations: evaluating a path
to a memory location and reading the value at that location.
We need to characterize the circumstances under which these operations will progress,
and we need to show that these operations preserve certain information, specifically
type and initialization data. Higher layers of Patina will build on these properties.
We shall start with typing paths and then move into defining evaluation for paths.

The typing judgment for paths does not present any surprises.
We use a partial map for the typing context and
the type substitution operation is the standard capture-avoiding substition.

$$ \gG : \mathrm{Variable} \to \mathrm{Type} $$

\fbox{$\tc{\gG}{\lv{x}{p}}{\gt}$}

\begin{mathpar}
\infer[PT-BASE]{\gG(x)=\gt}{\tc{\gG}{\lv{x}{\base}}{\gt}} \and
\infer[PT-DEOWN]{\tc{\gG}{\lv{x}{p}}{\own{\gt}}}{\tc{\gG}{\lv{x}{\deref{p}}}{\gt}} \and
\infer[PT-DEREF]{\tc{\gG}{\lv{x}{p}}{\tyref{\lt}{q}{\gt}}}{\tc{\gG}{\lv{x}{\deref{p}}}{\gt}} \and
\infer[PT-PROJ]{\tc{\gG}{\lv{x}{p}}{\subrec{\gt}{i}{n}}}{\tc{\gG}{\lv{x}{\proj{p}{i}}}{\gt_i}} \and
\infer[PT-UNROLL]
{\tc{\gG}{\lv{x}{p}}{\tyfix{X}{\gt}}}
{\tc{\gG}{\lv{x}{\unroll{\tyfix{X}{\gt}}{p}}}{\sub{X}{\tyfix{X}{\gt}}{\gt}}}
\end{mathpar}

\section*{Runtime Memory}

\subsection*{Representation and Addressing}

To accurately model Rust's memory usage, Patina restricts
the contents of a memory cell to void data, an integer, or a pointer to another cell.
Tuples and recursive types have no physical memory presence (beyond contiguity for tuples).
The memory representation of a variant is a pair of a cell for the discriminant
and whatever memory is necessary to store the payload.

We could model this by a map from addresses to memory cell values,
but two issues make this inconvenient: the need for address arithmetic
and non-unique typing. However, we can add a little extra structure to
our model and eliminate these two issues. We wrap the cells inside
layouts describing the type structure overlaying memory.

We also separate plain pointer cells into owned cells and reference cells.
This is mostly useful for providing just enough type information about the pointer
for memory operation purposes. We will explain how we address memory in a moment,
so we use a placeholder for now.

\[
\begin{array}{lccl}
\textrm{Integer} & z & & \\
\textrm{Address} & \rho & & \textrm{a placeholder} \\
\textrm{Cell} & c & \bnfdef & \void \bnfalt z \bnfalt \own{\rho} \bnfalt \Ref{q~\rho} \\
\textrm{Layout} & l & \bnfdef & c \bnfalt \varval{c}{l} \bnfalt 
			       \subrec{l}{i}{n} \bnfalt \roll{\gt}{l} \\
\end{array}
\]

Due to the extra structure from layouts, addressing memory now requires
more than simple labels. Instead we use a runtime analogue of variables and paths.
Allocations are chunks of memory allocated and freed atomically.
They correspond to either variables or heap allocations.
Routes are like paths except for two key differences.

\[
\begin{array}{lccl}
\textrm{Allocation} & \ga & & \\
\textrm{Route} & r & \bnfdef & \base \bnfalt \proj{r}{i} \bnfalt \pay{r} \bnfalt \unroll{\gt}{r} \\
\end{array}
\]

The $\base$ route, projection, and unrolling are effectively identical to their path equivalents.
The $\pay{r}$ route refers to the payload $l$ in a variant $\varval{c}{l}$.
This is primarily used for match-by-reference.
Unlike paths, there is no dereference route.
This forces any pointer following into path evaluation (into routes)
rather than doing so while reading memory at a route.
The address placeholder from before is simply a pair of an allocation label and a route.
The exception is that unique pointers need only an allocation since a unique pointer
always points to a complete heap allocation.
That is:

\[
\begin{array}{lccl}
\textrm{Integer} & z & & \\
\textrm{Allocation} & \ga & & \\
\textrm{Route} & r & \bnfdef & \base \bnfalt \proj{r}{i} \bnfalt \pay{r} \bnfalt \unroll{\gt}{r} \\
\textrm{Cell} & c & \bnfdef & \void \bnfalt z \bnfalt 
			      \own{\ga} \bnfalt \refval{q}{\addr{\ga}{r}} \\
\textrm{Layout} & l & \bnfdef & c \bnfalt \varval{c}{l} \bnfalt 
			       \subrec{l}{i}{n} \bnfalt \roll{\gt}{l} \\
\end{array}
\]

\subsection*{Reading}

Reading a layout from a route in memory is a straightforward operation.
We model the heap as a partial map from allocations to layouts.
Routes and layouts interact as you would expect.

$$ H : \mathrm{Allocation} \to \mathrm{Layout} $$

\fbox{$\Read{H}{\addr{\ga}{r}}{l}$}

\begin{mathpar}
\infer[RD-BASE]{H(\ga)=l}{\Read{H}{\addr{\ga}{\base}}{l}} \and
\infer[RD-PROJ]
  {\Read{H}{\addr{\ga}{r}}{\subrec{l}{i}{n}}}
  {\Read{H}{\addr{\ga}{\proj{r}{i}}}{l_i}} \and
\infer[RD-PAY]{\Read{H}{\addr{\ga}{r}}{\varval{c}{l}}}{\Read{H}{\addr{\ga}{\pay{r}}}{l}} \and
\infer[RD-UNROLL]{\Read{H}{\addr{\ga}{r}}{\roll{\gt'}{l}}}{\Read{H}{\addr{\ga}{\unroll{\gt}{r}}}{l}}
\end{mathpar}

As one would expect of a read operation, it's result is unique.

\begin{lem}[Read Uniqueness]
  If $\Read{H}{\addr{\ga}{r}}{l}$ and $\Read{H}{\addr{\ga}{r}}{l'}$, then $l = l'$.
\end{lem}

\begin{proof}[Read Uniqueness]
  We will induct on the derivation of $\Read{H}{\addr{\ga}{r}}{l}$.
  \begin{itemize}
    \item[\textsc{RD-BASE}] Then $r = \base$. \\
      By inversion, $H(\ga)=l$. \\
      There is only one rule (\textsc{RD-BASE}) for deriving $\Read{H}{\addr{\ga}{\base}}{l'}$. \\
      Thus, by inversion, $H(\ga)=l'$. \\
      Ergo, $l = l'$.
    \item[\textsc{RD-PROJ}] Then $r = \proj{r'}{i}$ and $l = l_i$. \\
      By inversion, $\Read{H}{\addr{\ga}{r'}}{\subrec{l}{i}{n}}$. \\
      There is only one rule (\textsc{RD-PROJ}) for
      deriving $\Read{H}{\addr{\ga}{\proj{r'}{i}}}{l'}$. \\
      Thus, by inversion, $\Read{H}{\addr{\ga}{r'}}{\subrec{l'}{i}{n'}}$. \\
      By induction, $\subrec{l}{i}{n} = \subrec{l'}{i}{n'}$. \\
      Ergo, $n = n'$ and $l_i = l'_i$.
    \item[\textsc{RD-PAY}] Then $r = \pay{r'}$. \\
      By inversion, $\Read{H}{\addr{\ga}{r'}}{\varval{c}{l}}$. \\
      There is only one rule (\textsc{RD-PAY}) for deriving $\Read{H}{\addr{\ga}{\pay{r'}}}{l'}$. \\
      Thus, by inversion, $\Read{H}{\addr{\ga}{r'}}{\varval{c'}{l'}}$. \\
      By induction, $\varval{c}{l} = \varval{c'}{l'}$. \\
      Ergo, $c = c'$ and $l = l'$.
    \item[\textsc{RD-UNROLL}] Then $r = \unroll{\gt}{r'}$. \\
      By inversion, $\Read{H}{\addr{\ga}{r'}}{\roll{\gt'}{l}}$. \\
      There is only one rule (\textsc{RD-UNROLL}) for
      deriving $\Read{H}{\addr{\ga}{\unroll{\gt}{r'}}}{l'}$. \\
      Thus, by inversion, $\Read{H}{\addr{\ga}{r'}}{\roll{\gt''}{l'}}$. \\
      By induction, $\roll{\gt'}{l} = \roll{\gt''}{l'}$. \\
      Ergo, $\gt' = \gt''$ and $l = l'$.
  \end{itemize}
\end{proof}

\section*{Path Evaluation}

Now that we can read memory, we can define path evaluation.
The only actual work of path evaluation is following the dereferences of pointers
to produce a route. In order to connect variables to runtime allocations, we use
a partial map tracking the allocation labels of variables.

$$ V : \mathrm{Variable} \to \mathrm{Allocation} $$

\fbox{$\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}$}

\begin{mathpar}
\infer[PE-BASE]{V(x)=\ga}{\ev{V;H}{\lv{x}{\base}}{\addr{\ga}{\base}}} \and
\infer[PE-DEOWN]
  {\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}} \\ \Read{H}{\addr{\ga}{r}}{\own{\ga'}}}
  {\ev{V;H}{\lv{x}{\deref{p}}}{\addr{\ga'}{\base}}} \and
\infer[PE-DEREF]
  {\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}} \\ \Read{H}{\addr{\ga}{r}}{\refval{q}{\addr{\ga'}{r'}}}}
  {\ev{V;H}{\lv{x}{\deref{p}}}{\addr{\ga'}{r'}}} \and
\infer[PE-PROJ]
  {\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}}
  {\ev{V;H}{\lv{x}{\proj{p}{i}}}{\addr{\ga}{\proj{r}{i}}}} \and
\infer[PE-UNROLL]
  {\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}}
  {\ev{V;H}{\lv{x}{\unroll{\gt}{p}}}{\addr{\ga}{\unroll{\gt}{r}}}}
\end{mathpar}

Our core operations are now defined,
but we still need to describe the typing of our runtime data
so that we can properly state and prove our type preservation lemmas.

\section*{Runtime Typing}
\subsection*{Route Typing}
Typing routes is much like typing paths; however, the $\pay{r}$ route requires
special attention. Since this route points to the payload of a variant,
its type depends upon the value of the discriminant of the variant.
This is used for handling match by reference.
The match arms have a pointer to the payload in scope, but the type of the
payload depends upon the value of the discrimiant.
For example,
\begin{verbatim}
  // x: <[], int> is a Patina encoding of Option<int>
  match x by imm y // y will have route `pay r' were `r' is the route of x
    // [] (None) case
    {
      // y: & imm [] is in scope here
    }
    // int (Some) case
    {
      // y: & imm int is in scope here
    }
\end{verbatim}

We handle this with an additional context that records the discriminant value
of a variant stored at a route. 

$$ \gS : \mathrm{Allocation} \to \mathrm{Type}$$
$$ \gY : \mathrm{Allocation} \times \mathrm{Route} \to \mathrm{Integer} $$

\fbox{$\tc{\gS;\gY}{\addr{\ga}{r}}{\gt} $}

\begin{mathpar}
\infer[RT-BASE]{\gS(\ga)=\gt}{\tc{\gS;\gY}{\addr{\ga}{\base}}{\gt}}
\and
\infer[RT-PROJ]
  {\tc{\gS;\gY}{\addr{\ga}{r}}{\subrec{\gt}{i}{n}}}
  {\tc{\gS;\gY}{\addr{\ga}{\proj{r}{i}}}{\gt_i}}
\and
\infer[RT-PAY]
  {\gY(\ga,r)=i \\ \tc{\gS;\gY}{\addr{\ga}{r}}{\subvar{\gt}{i}{n}}}
  {\tc{\gS;\gY}{\addr{\ga}{\pay{r}}}{\gt_i}}
\and
\infer[RT-UNROLL]
  {\tc{\gS;\gY}{\addr{\ga}{r}}{\tyfix{X}{\gt}}}
  {\tc{\gS;\gY}{\addr{\ga}{\unroll{\tyfix{X}{\gt}}{r}}}{\sub{X}{\tyfix{X}{\gt}}{\gt}}}
\end{mathpar}

\subsection*{Layout and Cell Typing}
Typing for layouts and cells is what you would expect.
However, we restrict the type of $\void$ to the possible types for other
kinds of cells, i.e. $\tyint$, unique pointers, and borrowed references.
This means that multi-cell layout types (variants, tuples, and recursive types) imply
a non-$\void$ value (though they can still contain $\void$s).
\newline

\fbox{$\tc{\gS;\gY}{l}{\gt}$}

\begin{mathpar}
\infer[LT-VOIDINT]
{ }
{\tc{\gS;\gY}{\void}{\tyint}}
\and
\infer[LT-VOIDOWN]
{ }
{\tc{\gS;\gY}{\void}{\own{\gt}}}
\and
\infer[LT-VOIDREF]
{ }
{\tc{\gS;\gY}{\void}{\tyref{\lt}{q}{\gt}}}
\and
\infer[LT-INT]
{ }
{\tc{\gS;\gY}{z}{\tyint}}
\and
\infer[LT-OWN]
{\tc{\gS;\gY}{\addr{\ga}{\base}}{\gt}}
{\tc{\gS;\gY}{\own{\ga}}{\own{\gt}}}
\and
\infer[LT-REF]
{\tc{\gS;\gY}{\addr{\ga}{r}}{\gt}}
{\tc{\gS;\gY}{\refval{q}{\addr{\ga}{r}}}{\tyref{\lt}{q}{\gt}}}
\and
\infer[LT-VOIDVAR]
{ }
{\tc{\gS;\gY}{\varval{\void}{\void}}{\subvar{\gt}{i}{n}}}
\and
\infer[LT-VAR]
{\tc{\gS;\gY}{l}{\gt_i}}
{\tc{\gS;\gY}{\varval{i}{l}}{\subvar{\gt}{i}{n}}}
\and
\infer[LT-REC]
{\forall i.~\tc{\gS;\gY}{l_i}{\gt_i}}
{\tc{\gS;\gY}{\subrec{l}{i}{n}}{\subrec{\gt}{i}{n}}}
\and
\infer[LT-ROLL]
{\tc{\gS;\gY}{l}{\sub{X}{\tyfix{X}{\gt}}{\gt}}}
{\tc{\gS;\gY}{\roll{\tyfix{X}{\gt}}{l}}{\tyfix{X}{\gt}}}
\end{mathpar}

\subsection*{Heap Well-Formedness}
With runtime typing now in hand, we can say what it means for the heap to be well-formed.
We say a heap $H$ is described by a heap type $\gS$ and a discriminant context $\gY$ if
every allocation in $H$ has the type assigned to it by $\gS$
and $\gY$ correctly records the discrimiants of all the variants in $H$.
The last hypothesis enforces the uniqueness of unique pointers by requiring
that if a unique pointer is at any address, then that address is unique.
This strengthens our induction hypothesis enough to show that no memory has
multiple owners, which we need to prove that no double frees occur.
Ensuring every piece of memory has at least one owner is handled elsewhere.
Formally,

\begin{mathpar}
\mprset{flushleft}
\infer
{\dom{H} = \dom{\gS} \\\\
\forall \ga \in \dom(\gS).~\gS(\ga)~\textrm{closed} \\\\
\forall \ga \in \dom{H}.~\tc{\gS;\gY}{H(\ga)}{\gS(\ga)} \\\\
\forall (\ga,r) \in \dom{\gY}.~\Read{H}{\addr{\ga}{r}}{\varval{\gY(\ga,r)}{l}} \\\\
\forall \ga, \ga', \ga'' \in \dom H.\ \forall r, r.\ 
    \Read{H}{\addr{\ga}{r}}{\own{\ga''}} \land
    \Read{H}{\addr{\ga'}{r'}}{\own{\ga''}} \implies \addr{\ga}{r} = \addr{\ga'}{r'} }
{\tc{}{H}{\gS;\gY}}
\end{mathpar}

\section*{Read Safety}
We are now in position to prove that our read operation is safe.
That is, if the heap is well formed and a route is has some type,
then we can read some layout at that route and that layout has that same type.
This is effectively a merger of the type preservation and progress lemmas for \textsc{read}.

\begin{lem}[Read Safety]
If $\tc{}{H}{\gS;\gY}$ and $\tc{\gS;\gY}{\addr{\ga}{r}}{\gt}$,
then there is a layout $l$ such that $\Read{H}{\addr{\ga}{r}}{l}$ and $\tc{\gS;\gY}{l}{\gt}$.
\end{lem}

\begin{proof}[Read Safety]
  We will use induction on the derivation of $\tc{\gS;\gY}{\addr{\ga}{r}}{\gt}$.
  \begin{itemize}
    \item[\textsc{RT-BASE}] Then $r = \base$. \\
      By inversion, $\gS(\ga)=\gt$. \\
      From $\tc{}{H}{\gS;\gY}$, we know that $\dom{H}=\dom{\gS}$.
      Thus, $\exists l.~H(\ga)=l$. \\
      Then by \textsc{RD-BASE}, we have $\Read{H}{\addr{\ga}{\base}}{l}$. \\
      Again from $\tc{}{H}{\gS;\gY}$, we know that $\tc{\gS;\gY}{H(\ga)}{\gS(\ga)}$,
      which is just $\tc{\gS;\gY}{l}{\gt}$ as required.
    \item[\textsc{RT-PROJ}] Then $r = \proj{r'}{i}$ and $\gt = \gt_i$. \\
      By inversion, $\tc{\gS;\gY}{\addr{\ga}{r'}}{\subrec{\gt}{i}{n}}$. \\
      By induction, $\Read{H}{\addr{\ga}{r'}}{l}$
      and $\tc{\gS;\gY}{l}{\subrec{\gt}{i}{n}}$ for some $l$. \\
      There is only one rule (\textsc{LT-REC}) for deriving $\tc{\gS;\gY}{l}{\subrec{\gt}{i}{n}}$. \\
      Thus, by inversion, $l = \subrec{l'}{j}{n}$ 
      and $\forall j.~\tc{\gS;\gY}{l'_j}{\gt_j}$.
      Specifically, $\tc{\gS;\gY}{l'_i}{\gt_i}$. \\
      Then by \textsc{RD-PROJ}, we have $\Read{H}{\addr{\ga}{\proj{r'}{i}}}{l'_i}$.
    \item[\textsc{RT-PAY}] Then $r = \pay{r'}$ and $\gt = \gt_i$. \\
      By inversion, $\gY(\ga,r')=i$ and $\tc{\gS;\gY}{\addr{\ga}{r'}}{\subvar{\gt}{i}{n}}$. \\
      By induction, $\Read{H}{\addr{\ga}{r'}}{l}$
      and $\tc{\gS;\gY}{l}{\subvar{\gt}{i}{n}}$. \\
      From $\tc{}{H}{\gS;\gY}$, we know that because $\gY(\ga,r')=i$
      it follows that $\Read{H}{\addr{\ga}{r'}}{\varval{i}{l'}}$ for some $l'$. \\
      By Read Uniqueness, we know that $l = \varval{i}{l'}$. \\
      There is only one rule (\textsc{LT-VAR}) for deriving 
      $\tc{\gS;\gY}{\varval{i}{l'}}{\subvar{\gt}{i}{n}}$. \\
      Thus, by inversion, $\tc{\gS;\gY}{l'}{\gt_i}$. \\
      Then by \textsc{RD-PAY}, we have $\Read{H}{\addr{\ga}{\pay{r'}}}{l'}$.
    \item[\textsc{RT-UNROLL}] 
      Then $r = \unroll{\tyfix{X}{\gt'}}{r'}$ and $\gt = \sub{X}{\tyfix{X}{\gt'}}{\gt'}$. \\
      By inversion, $\tc{\gS;\gY}{\addr{\ga}{r'}}{\tyfix{X}{\gt'}}$. \\
      By induction, $\Read{H}{\addr{\ga}{r'}}{l}$ 
      and $\tc{\gS;\gY}{l}{\tyfix{X}{\gt'}}$ for some $l$. \\
      There is only one rule (\textsc{LT-ROLL}) for deriving $\tc{\gS;\gY}{l}{\tyfix{X}{\gt'}}$. \\
      Thus, by inversion, $l = \roll{\tyfix{X}{\gt'}}{l'}$
      and $\tc{\gS;\gY}{l'}{\sub{X}{\tyfix{X}{\gt'}}{\gt'}}$. \\
      Then by \textsc{RD-UNROLL}, we have
      $\Read{H}{\addr{\ga}{\unroll{\tyfix{X}{\gt'}}{r'}}}{l'}$.
  \end{itemize}
\end{proof}

\section*{Path Type Preservation}
The final piece we need for preservation is how to relate the typing context $\gG$,
the variable map $V$, and the heap type $\gS$. This is simply the requirement that
the map $V$ preserves typing.

\begin{mathpar}
  \infer
  {\forall x \in \dom{\gG}.~\gG(x)=\gS(V(x))}
  {\gG;V\vdash\gS}
\end{mathpar}

Finally, we can state and prove path type preservation.
Under well-formed heap and contexts, typed paths evaluate to routes of the same type.

\begin{lem}[Path Type Preservation]
  If $\tc{}{H}{\gS;\gY}$, $\gG;V\vdash\gS$, $\tc{\gG}{\lv{x}{p}}{\gt}$,
  and $\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}$, then $\tc{\gS;\gY}{\addr{\ga}{r}}{\gt}$.
\end{lem}

\begin{proof}[Path Type Preservation]
  We will use induction on the derivation of $\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}$.
  \begin{itemize}
    \item[PE-BASE] Then $p = \base$ and $r = \base$. \\
      By inversion, $V(x)=\ga$. \\
      There is only one rule (\textsc{PT-BASE}) for deriving $\tc{\gG}{\lv{x}{\base}}{\gt}$. \\
      Thus, by inversion, we have $\gG(x)=\gt$. \\
      From $\gG;V\vdash\gS$, we know $\gG(x)=\gS(V(x))$. Thus, $\gt=\gS(\ga)$. \\
      Then by \textsc{RT-BASE}, we have $\tc{\gS;\gY}{\addr{\ga}{\base}}{\gt}$.
    \item[PE-DEOWN] Then $p = \deref{p'}$ and $r = \base$. \\
      By inversion, $\ev{V;H}{\lv{x}{p'}}{\addr{\ga'}{r'}}$
      and $\Read{H}{\addr{\ga'}{r'}}{\own{\ga}}$. \\
      There are two possible rules for deriving $\tc{\gG}{\lv{x}{\deref{p'}}}{\gt}$.
      \begin{itemize}
	\item[PT-DEOWN]
	  By inversion, $\tc{\gG}{\lv{x}{p'}}{\own{\gt}}$. \\
	  By induction, $\tc{\gS;\gY}{\addr{\ga'}{r'}}{\own{\gt}}$. \\
	  By Read Safety, we have $\Read{H}{\addr{\ga'}{r'}}{l}$
	  and $\tc{\gS;\gY}{l}{\own{\gt}}$ for some $l$. \\
	  By Read Uniqueness, we have $l =\ \own{\ga}$. \\
	  There is only one rule (\textsc{LT-OWN}) for deriving 
	  $\tc{\gS;\gY}{\own{\ga}}{\own{\gt}}$. \\
	  Thus, by inversion, $\tc{\gS;\gY}{\addr{\ga}{\base}}{\gt}$.
	\item[PT-DEREF]
	  By inversion, $\tc{\gG}{\lv{x}{p'}}{\tyref{\lt}{q}{\gt}}$. \\
	  By induction, $\tc{\gS;\gY}{\addr{\ga'}{r'}}{\tyref{\lt}{q}{\gt}}$. \\
	  By Read Safety, we have $\Read{H}{\addr{\ga'}{r'}}{l}$
	  and $\tc{\gS;\gY}{l}{\tyref{\lt}{q}{\gt}}$ for some $l$. \\
	  By Read Uniqueness, we have $l =\ \own{\ga}$. \\
	  There are no rules for deriving
	  $\tc{\gS;\gY}{\own{\ga}}{\tyref{\lt}{q}{\gt}}$. \\
	  Thus, by inversion, this case is impossible.
      \end{itemize}
    \item[PE-DEREF] 
      Similar to the \textsc{PE-DEOWN} case, but switching the roles of
      \textsc{PT-DEOWN} and \textsc{PT-DEREF}.
    \item[PE-PROJ] Then $p = \proj{p'}{i}$ and $r = \proj{r'}{i}$. \\
      By inversion, $\ev{V;H}{\lv{x}{p'}}{\addr{\ga}{r'}}$. \\
      There is only one rule (\textsc{PT-PROJ}) for deriving $\tc{\gG}{\lv{x}{\proj{p'}{i}}}{\gt}$. \\
      Thus, by inversion, we have $\gt = \gt_i$ and $\tc{\gG}{\lv{x}{p'}}{\subrec{\gt}{i}{n}}$. \\
      By induction, we have $\tc{\gS;\gY}{\addr{\ga}{r'}}{\subrec{\gt}{i}{n}}$. \\
      Then by \textsc{RT-PROJ}, we have $\tc{\gS;\gY}{\addr{\ga}{\proj{r'}{i}}}{\gt_i}$.
    \item[PE-UNROLL] Then $p = \unroll{\gt'}{p'}$ and $r = \unroll{\gt'}{r'}$. \\
      By inversion, $\ev{V;H}{\lv{x}{p'}}{\addr{\ga}{r'}}$. \\
      There is only one rule (\textsc{PT-UNROLL}) for deriving
      $\tc{\gG}{\lv{x}{\unroll{\gt'}{p'}}}{\gt}$. \\
      Thus, by inversion, we have $\gt' = \tyfix{X}{\gt''}$,
      $\gt = \sub{X}{\tyfix{X}{\gt''}}{\gt''}$, and
      $\tc{\gG}{\lv{x}{p'}}{\tyfix{X}{\gt''}}$. \\
      By induction, we have $\tc{\gS;\gY}{\addr{\ga}{r'}}{\tyfix{X}{\gt''}}$. \\
      Then by \textsc{RT-UNROLL}, we have
      $\tc{\gS;\gY}{\addr{\ga}{\unroll{\tyfix{X}{\gt''}}{r'}}}{\sub{X}{\tyfix{X}{\gt''}}{\gt''}}$.
  \end{itemize}
\end{proof}

\section*{Tracking Initialization}
Types are only half of the information we need to preserve.
To properly type check Patina, we need to know which paths point to initialized memory
and which do not. This is important for ensuring we never use uninitialized memory and
that we correctly free heap memory.
We will accomplish this by creating a shadow heap.
Instead of tracking actual values, we will simply track whether a cell is initialized.
Paths will serve the same function for this shadow heap as routes do for the real heap.

\[
\begin{array}{lccl}
\textrm{Hole} & h & \bnfdef & \uninit \bnfalt \tyint \bnfalt \own{\gs} 
				      \bnfalt \refval{q}{\gt} \bnfalt \subvar{\gt}{i}{n} \\
\textrm{Shadow} & \gs & \bnfdef & h \bnfalt \subrec{\gs}{i}{n} \bnfalt \roll{\gt}{\gs} \\
\end{array}
\]

Since shadows and holes are supposed to be a shadow of the heap,
it is unsurprising that they are very similar to layouts and cells.
However, there are a few key differences.
First, variants are considered an atomic value (and thus a hole) rather than
a structure. This is because the discrimiant and payload of a variant always
share the same initialization state.
Second, while the pointer cells contain routes, the pointer holes do not
contain paths (the analogue of routes).
For references, there is no need because references always point to fully initialized things.
Therefore, the reference hole simply records the type of the reference.
For unique pointers, there is no path that could possibly be used
(otherwise the pointer would not be unique).
Therefore, the unique pointer hole records the shadow of the pointed-to heap memory.

Two examples are useful for understanding shadows.
First, consider nested pointers:
\begin{verbatim}
{
  let x: ~~int = ~~3;
  // Here the shadow of x is `~ ~ int'
  // x, *x, and **x are all initialized

  let y: ~int = *x; // *x is now deinitialized
  // Here the shadow of x is `~ uninit' and the shadow of y is `~ int'
  // x is initialized, but *x and **x are not
  // both y and *y are initialized
}
\end{verbatim}

Second, consider tuples:
\begin{verbatim}
{
  let x: [~int, ~int] = [~1, ~2];
  // Here the shadow of x is [~int, ~int]
  // x, x.1, *(x.1), x.2, and *(x.2) are all initialized

  free(x.1);
  // Here the shadow of x is [uninit, ~int]
  // x, x.1, x.2, and *(x.2) are all initialized, but *(x.1) is not
}
\end{verbatim}

The shadow heap gives the typechecker enough information 
to ensure we do not use or dereference uninitialized memory.
For example, here is how it can catch dereferencing a null pointer:
\begin{verbatim}
{
  let x: ~~int = ~~3;
  free(*x); // deallocates **x, leaving *x uninitialized
  // at this point the shadow of x is `~ uninit'
  let y: int = **x; // ERROR! dereferences a null pointer *x
  // the type checker know the shadow of *x is `uninit'
  // if a further dereference was allowed (i.e. **x), a null pointer derefernce would occur
  // the type checker can avoid null pointer dereferences by forbidding derefs of `uninit' data

}
\end{verbatim}

It can also catch a missing free that would leak memory.
\begin{verbatim}
{
  let x: ~int = ~3;
  // the shadow of x is `~ int'

  // the stack variable x will be popped off the stack, leaking the heap memory at *x
  // the type checker can identify this error by seeing that the shadow of x contains `~' data
  // by requiring that shadows cannot contain `~' when freed, the type checker prevents leaks
}
\end{verbatim}

\section*{Checking Shallow Initialization}
We will need an analogue of \textsc{read} for our shadow heap for the
simple purpose of extracting the shadow at a path in the same way we
need to extract the layout at a route from the heap.
However, this analogue also serves as a very useful property checker:
any dereferences in the path are dereferences of initialized memory.
This property, called \emph{shallow initialization} is exactly what we need
for path progress. A shallowly initialized path can successfully dereference
all the pointers necessary to evaluate to a route.
For this reason, we call this operation \textsc{shallow}.
To support dereferencing borrowed references, 
we need to construct a shape from the referenced type.
We do this with the \textsc{init} function.
\newline

\fbox{$\textsc{init} : \textrm{Type} \to \textrm{Shadow}$}

\[
\begin{array}{lcl}
\initShadow{\tyint} &=& \tyint \\
\initShadow{\own{\gt}} &=& \own{\initShadow{\gt}} \\
\initShadow{\tyref{\lt}{q}{\gt}} &=& \refval{q}{\gt} \\
\initShadow{\subrec{\gt}{i}{n}} &=& [\initShadow{\gt_i}]_{i \in \{1\ldots n\}} \\
\initShadow{\subvar{\gt}{i}{n}} &=& \subvar{\gt}{i}{n} \\
\initShadow{\tyfix{X}{\gt}} &=& \roll{\tyfix{X}{\gt}}{\initShadow{\sub{X}{\tyfix{X}{\gt}}{\gt}}} \\
\end{array}
\]

We also need a new context recording the shadows of stack variables.

$$ \gU : \textrm{Variable} \to \textrm{Shadow} $$

\fbox{$\shallow{\gU}{\lv{x}{p}}{\gs}$}

\begin{mathpar}
\infer[SI-BASE]
{\gU(x)=\gs}
{\shallow{\gU}{\lv{x}{\base}}{\gs}}
\and
\infer[SI-DEOWN]
{\shallow{\gU}{\lv{x}{p}}{\own{\gs}}}
{\shallow{\gU}{\lv{x}{\deref{p}}}{\gs}}
\and
\infer[SI-DEREF]
{\shallow{\gU}{\lv{x}{p}}{\refval{q}{\gt}} \\ \initShadow{\gt}=\gs}
{\shallow{\gU}{\lv{x}{\deref{p}}}{\gs}}
\and
\infer[SI-PROJ]
{\shallow{\gU}{\lv{x}{p}}{\subrec{\gs}{i}{n}}}
{\shallow{\gU}{\lv{x}{\proj{p}{i}}}{\gs_i}}
\and
\infer[SI-UNROLL]
{\shallow{\gU}{\lv{x}{p}}{\roll{\gt'}{\gs}}}
{\shallow{\gU}{\lv{x}{\unroll{\gt}{p}}}{\gs}}
\end{mathpar}

\section*{Shadow Typing}
We need to ensure that the shadows assigned to variables are consistent with the types
assigned to variables, i.e. we want to avoid situations like
$\gG(x)=\tyint$ and $\gU(x)=\refval{\qimm}{\tyint}$.
We can easily do this by defining a typing judgement for shadows and
defining a well-formedness condition for $\gU$ that ensures it is consistent with $\gG$.
Similar to typing for layouts, $\uninit$ can only have types that other holes can have.

\fbox{$\tc{}{\gs}{\gt}$}

\begin{mathpar}
\infer[ST-UNINT]
{ }
{\tc{}{\uninit}{\tyint}}
\and
\infer[ST-UNOWN]
{ }
{\tc{}{\uninit}{\own{\gt}}}
\and
\infer[ST-UNREF]
{ }
{\tc{}{\uninit}{\tyref{\lt}{q}{\gt}}}
\and
\infer[ST-UNVAR]
{ }
{\tc{}{\uninit}{\subvar{\gt}{i}{n}}}
\and
\infer[ST-INT]
{ }
{\tc{}{\tyint}{\tyint}}
\and
\infer[ST-OWN]
{\tc{}{\gs}{\gt}}
{\tc{}{\own{\gs}}{\own{\gt}}}
\and
\infer[ST-REF]
{ }
{\tc{}{\refval{q}{\gt}}{\tyref{\lt}{q}{\gt}}}
\and
\infer[ST-VAR]
{ }
{\tc{}{\subvar{\gt}{i}{n}}{\subvar{\gt}{i}{n}}}
\and
\infer[ST-REC]
{\forall i.~\tc{}{\gs_i}{\gt_i}}
{\tc{}{\subrec{\gs}{i}{n}}{\subrec{\gt}{i}{n}}}
\and
\infer[ST-ROLL]
{\tc{}{\gs}{\sub{X}{\tyfix{X}{\gt}}{\gt}}}
{\tc{}{\roll{\tyfix{X}{\gt}}{\gs}}{\tyfix{X}{\gt}}}
\end{mathpar}

\begin{mathpar}
\mprset{flushleft}
\infer
{ 
\dom{\gG}=\dom{\gU} \\\\
\forall x \in \dom{\gG}.~\gG(x)~\textrm{closed} \\\\
\forall x \in \dom{\gG}.~\tc{}{\gU(x)}{\gG(x)}
}
{\tc{}{\gU}{\gG}}
\end{mathpar}

\subsection*{The INIT Function Preserves Types}
Since the \textsc{init} function is supposed to be the
fully initialized shadow of the argument type, it should
be the case that the resulting shadow has that type.
Since \textsc{init} is only defined on closed types, 
we must restrict ourselves to them.
\begin{lem}[\textsc{init} Type Preservation]
  If $\gt$ is closed, then $\tc{}{\initShadow{\gt}}{\gt}$.
\end{lem}

\begin{proof}[\textsc{init} Type Preservation]
  Induction on the form of $\gt$.
  \begin{itemize}
    \item[INT]
      If $\gt = \tyint$, then $\initShadow{\tyint}=\tyint$.
      From \textsc{ST-INT}, we have $\tc{}{\tyint}{\tyint}$.
    \item[OWN]
      If $\gt = \own{\gt'}$, then $\initShadow{\own{\gt'}}=\ \own{\initShadow{\gt'}}$. \\
      Since $\gt$ is closed, $\gt'$ is also closed. \\
      Thus, by induction, $\tc{}{\initShadow{\gt'}}{\gt'}$. \\
      From \textsc{ST-OWN}, we have $\tc{}{\own{\initShadow{\gt'}}}{\own{\gt'}}$.
    \item[REF]
      If $\gt = \tyref{\lt}{q}{\gt'}$, 
      then $\initShadow{\tyref{\lt}{q}{\gt'}}=\refval{q}{\gt'}$. \\
      $\tc{}{\refval{q}{\gt'}}{\tyref{\lt}{q}{\gt'}}$ follows immediately by \textsc{ST-REF}.
    \item[REC]
      If $\gt = \subrec{\gt'}{i}{n}$,
      then $\initShadow{\subrec{\gt'}{i}{n}}=[\initShadow{\gt'_i}]_{i\in\{1\ldots n\}}$. \\
      Since $\gt$ is closed, $\gt'_i$ is closed for all $i$. \\
      Thus, by induction, for all $i$ we have $\tc{}{\initShadow{\gt'_i}}{\gt'_i}$. \\
      Then by \textsc{ST-REC}, we have 
      $\tc{}{[\initShadow{\gt'_i}]_{i\in\{1\ldots n\}}}{\subrec{\gt'}{i}{n}}$.
    \item[VAR]
      If $\gt = \subvar{\gt'}{i}{n}$,
      then $\initShadow{\subvar{\gt'}{i}{n}}=\subvar{\gt'}{i}{n}$. \\
      $\tc{}{\subvar{\gt'}{i}{n}}{\subvar{\gt'}{i}{n}}$ follows immediately from \textsc{ST-VAR}.
    \item[FIX]
      If $\gt = \tyfix{X}{\gt'}$,
      then $\initShadow{\tyfix{X}{\gt'}} 
         = \roll{\tyfix{X}{\gt'}}{\initShadow{\sub{X}{\tyfix{X}{\gt'}}{\gt'}}}$. \\
      Since $\gt$ is closed, $\gt'$ might not be closed;
      however, the only possible free variable is $X$. \\
      Thus, the unrolling $\sub{X}{\tyfix{X}{\gt'}}{\gt'}$ is closed. \\
      Hence, by induction, 
      $\tc{}{\initShadow{\sub{X}{\tyfix{X}{\gt'}}{\gt'}}}{\sub{X}{\tyfix{X}{\gt'}}{\gt'}}$. \\
      Then by \textsc{ST-ROLL}, we have
      $\tc{}{\roll{\tyfix{X}{\gt'}}{\initShadow{\sub{X}{\tyfix{X}{\gt'}}{\gt'}}}}
	    {\tyfix{X}{\gt'}}$.
  \end{itemize}
\end{proof}

\subsection*{Shallow Preserves Types}
Just as with \textsc{read}, \textsc{shallow} preserves types.
This lemma is used primarily to demonstrate the impossibility 
of certain subcases of dereferences in later proofs.

\begin{lem}[\textsc{shallow} Type Preservation]
  If $\tc{}{\gU}{\gG}$, $\tc{\gG}{\lv{x}{p}}{\gt}$, and $\shallow{\gU}{\lv{x}{p}}{\gs}$
  then $\tc{}{\gs}{\gt}$.
\end{lem}

\begin{proof}[\textsc{shallow} Type Preservation]
  Induction on the derivation of $\shallow{\gU}{\lv{x}{p}}{\gs}$.
  \begin{itemize}
    \item[SI-BASE] Then $p = \base$. \\
      By inversion, $\gU(x)=\gs$. \\
      There is only one rule (\textsc{PT-BASE}) for deriving $\tc{\gG}{\lv{x}{\base}}{\gt}$. \\
      Thus, by inversion, we have $\gG(x)=\gt$. \\
      From $\tc{}{\gU}{\gG}$, we have $\tc{}{\gU(x)}{\gG(x)}$. \\
      Ergo, we have $\tc{}{\gs}{\gt}$.
    \item[SI-DEOWN] Then $p = \deref{p'}$. \\
      By inversion, $\shallow{\gU}{\lv{x}{p'}}{\own{\gs}}$. \\
      There are two possible rules for deriving $\tc{\gG}{\lv{x}{\deref{p'}}}{\gt}$.
      \begin{itemize}
	\item[PT-DEOWN]
	  By inversion, $\tc{\gG}{\lv{x}{p'}}{\own{\gt}}$. \\
	  By induction, $\tc{}{\own{\gs}}{\own{\gt}}$. \\
	  There is only one rule (\textsc{ST-OWN}) for deriving $\tc{}{\own{\gs}}{\own{\gt}}$. \\
	  Thus, by inversion, $\tc{}{\gs}{\gt}$.
	\item[PT-DEREF]
	  By inversion, $\tc{\gG}{\lv{x}{p'}}{\tyref{\lt}{q}{\gt}}$. \\
	  By induction, $\tc{}{\own{\gs}}{\tyref{\lt}{q}{\gt}}$. \\
	  There are no rules for deriving $\tc{}{\own{\gs}}{\tyref{\lt}{q}{\gt}}$. \\
	  Thus, by inversion, this case is impossible.
      \end{itemize}
    \item[SI-DEREF] Then $p = \deref{p'}$. \\
      By inversion, $\shallow{\gU}{\lv{x}{p'}}{\refval{q}{\gt}}$ and $\initShadow{\gt}=\gs$. \\
      There are two possible rules for deriving $\tc{\gG}{\lv{x}{\deref{p'}}}{\gt}$.
      \begin{itemize}
	\item[PT-DEOWN]
	  By inversion, $\tc{\gG}{\lv{x}{p'}}{\own{\gt}}$. \\
	  By induction, $\tc{}{\refval{q}{\gt}}{\own{\gt}}$. \\
	  There are no rules for deriving $\tc{}{\refval{q}{\gt}}{\own{\gt}}$. \\
	  Thus, by inversion, this case is impossible.
	\item[PT-DEREF]
	  By inversion, $\tc{\gG}{\lv{x}{p'}}{\tyref{\lt}{q}{\gt}}$. \\
	  Since $\tc{}{\gU}{\gG}$ guarantees that $\gG(x)$ is closed
	  and a simple inspection of the path typing rules shows that
	  this implies all well typed paths have closed types,
	  we know that $\gt$ is closed. \\
	  By \textsc{init} Type Preservation, $\textsc{init}(\gt)=\gs$ implies $\tc{}{\gs}{\gt}$.
      \end{itemize}
    \item[SI-PROJ] Then $p = \proj{p'}{i}$ and $\gs = \gs_i$. \\
      By inversion, $\shallow{\gU}{\lv{x}{p'}}{\subrec{\gs}{i}{n}}$. \\
      There is only one rule (\textsc{PT-PROJ}) for deriving 
      $\tc{\gG}{\lv{x}{\proj{p'}{i}}}{\gt}$. \\
      Thus, by inversion, we have $\gt=\gt_i$ and $\tc{\gG}{\lv{x}{p'}}{\subrec{\gt}{i}{n}}$. \\
      By induction, we have $\tc{}{\subrec{\gs}{i}{n}}{\subrec{\gt}{i}{n}}$. \\
      There is only one rule (\textsc{ST-REC}) for 
      deriving $\tc{}{\subrec{\gs}{i}{n}}{\subrec{\gt}{i}{n}}$. \\
      Thus, by inversion, we have $\tc{}{\gs_i}{\gt_i}$.
    \item[SI-UNROLL] Then $p = \unroll{\gt'}{p'}$. \\
      By inversion, $\shallow{\gU}{\lv{x}{p'}}{\roll{\gt''}{\gs}}$. \\
      There is only one rule (\textsc{PT-UNROLL}) for deriving
      $\tc{\gG}{\lv{x}{\unroll{\gt'}{p'}}}{\gt}$. \\
      By inversion, $\gt' = \tyfix{X}{\gt'''}$, $\gt = \sub{X}{\tyfix{X}{\gt'''}}{\gt'''}$,
      and $\tc{\gG}{\lv{x}{p'}}{\tyfix{X}{\gt'''}}$. \\
      By induction, $\tc{}{\roll{\gt''}{\gs}}{\tyfix{X}{\gt'''}}$. \\
      There is only one rule (\textsc{ST-ROLL}) for deriving this. \\
      Thus, by inversion, we have $\gt'' = \tyfix{X}{\gt'''}$ and 
      $\tc{}{\gs}{\sub{X}{\tyfix{X}{\gt'''}}{\gt'''}}$.
  \end{itemize}
\end{proof}

\section*{Shadow Checking the Heap}
Of course, we also need to check that our shadow heap correctly models
the actual heap. For the most part, it is exactly the relation you would expect.
The use of \textsc{init} in \textsc{LS-REF} and \textsc{LS-VAR} ensures that
the pointees of borrowed references and the payload of initialized variants
are fully initialized.
The $\textsc{droppable}(l)$ judgment checks that $l$ owns no initialized heap memory,
i.e. $\own{\addr{\ga}{r}}$ is not reachable from $l$ except through references.
These layouts are safe to deallocate because we cannot leak heap memory by doing so.
The $\tc{V}{H}{\gU}$ judgment ensures that the shadow heap corresponds to the real heap.
\newline

\fbox{$\textsc{droppable}(l)$}

\begin{mathpar}
\infer[D-VOID]
{ }
{\textsc{droppable}(\void)}
\and
\infer[D-INT]
{ }
{\textsc{droppable}(z)}
\and
\infer[D-REF]
{ }
{\textsc{droppable}(\refval{q}{\addr{\ga}{r}})}
\and
\infer[D-VAR]
{\textsc{droppable}(c) \\ \textsc{droppable}(l)}
{\textsc{droppable}(\varval{c}{l})}
\and
\infer[D-REC]
{\forall i.~\textsc{droppable}(l_i)}
{\textsc{droppable}(\subrec{l}{i}{n})}
\and
\infer[D-ROLL]
{\textsc{droppable}(l)}
{\textsc{droppable}(\roll{\gt}{l})}
\end{mathpar}

\fbox{$\tc{H}{l}{\gs}$}

\begin{mathpar}
\infer[LS-VOID]
{ }
{\tc{H}{\void}{\uninit}}
\and
\infer[LS-INT]
{ }
{\tc{H}{z}{\tyint}}
\and
\infer[LS-OWN]
{\Read{H}{\addr{\ga}{\base}}{l} \\ \tc{H}{l}{\gs}}
{\tc{H}{\own{\ga}}{\own{\gs}}}
\and
\infer[LS-REF]
{\Read{H}{\addr{\ga}{r}}{l} \\ \tc{H}{l}{\initShadow{\gt}}}
{\tc{H}{\refval{q}{\addr{\ga}{r}}}{\refval{q}{\gt}}}
\and
\infer[LS-VOIDVAR]
{ }
{\tc{H}{\varval{\void}{\void}}{\uninit}}
\and
\infer[LS-DROPVAR]
{\textsc{droppable}(l)}
{\tc{H}{\varval{i}{l}}{\uninit}}
\and
\infer[LS-VAR]
{\tc{H}{l}{\initShadow{\gt_i}}}
{\tc{H}{\varval{i}{l}}{\subvar{\gt}{i}{n}}}
\and
\infer[LS-REC]
{\forall i.~\tc{H}{l_i}{\gs_i}}
{\tc{H}{\subrec{l}{i}{n}}{\subrec{\gs}{i}{n}}}
\and
\infer[LS-ROLL]
{\tc{H}{l}{\gs}}
{\tc{H}{\roll{\tyfix{X}{\gt}}{l}}{\roll{\tyfix{X}{\gt}}{\gs}}}
\end{mathpar}

\begin{mathpar}
\mprset{flushleft}
\infer
{ 
\dom{V}=\dom{\gU} \\\\
\dom H = \textsc{reachable}(V,H) \\\\
\forall x \in \dom{V}.~\tc{H}{H(V(x))}{\gU(x)}
}
{\tc{V}{H}{\gU}}
\end{mathpar}

\section*{Shadow Preservation}
The initialization data, in the form of a shadow,
is preserved by path evaulation and \textsc{read}
so that the resulting layout is correctly described by the shadow.

\begin{lem}[Shadow Preservation]
  If $\tc{V}{H}{\gU}$, $\shallow{\gU}{\lv{x}{p}}{\gs}$, 
  $\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}$ , and $\Read{H}{\addr{\ga}{r}}{l}$
  then $\tc{H}{l}{\gs}$.
\end{lem}

\begin{proof}[Shadow Preservation]
  Induction on the derivation fo $\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}$.
  \begin{itemize}
    \item[\textsc{PE-BASE}] 
      Then $p = \base$ and $r = \base$.\\
      By inversion, $V(x)=\ga$.\\
      There is only one rule (\textsc{SI-BASE}) for deriving $\shallow{\gU}{\lv{x}{\base}}{\gs}$.\\
      Thus, by inversion, $\gU(x)=\gs$.\\
      There is only one rule (\textsc{RD-BASE}) for deriving $\Read{H}{\addr{\ga}{\base}}{l}$.\\
      Thus, by inversion, $H(\ga)=l$.\\
      By $\tc{V}{H}{\gU}$, we have $\tc{H}{H(V(x))}{\gU(x)}$. \\
      However, this is just $\tc{H}{l}{\gs}$ as required.
    \item[\textsc{PE-DEOWN}] 
      Then $p = \deref{p'}$ and $r = \base$.\\
      By inversion, $\ev{V;H}{\lv{x}{p'}}{\addr{\ga'}{r'}}$ 
      and $\Read{H}{\addr{\ga'}{r'}}{\own{\ga}}$. \\
      There are two possible rules for deriving $\shallow{\gU}{\lv{x}{\deref{p'}}}{\gs}$.
      \begin{itemize}
	\item[\textsc{SI-DEOWN}]
	  By inversion, $\shallow{\gU}{\lv{x}{p'}}{\own{\gs}}$.\\
	  By induction, $\tc{H}{\own{\ga}}{\own{\gs}}$.\\
	  There is only one rule (\textsc{LS-OWN}) for deriving this.\\
	  Thus, by inversion, we have $\Read{H}{\addr{\ga}{\base}}{l'}$ and $\tc{H}{l'}{\gs}$.\\
	  By Read Uniqueness, we have $l' = l$.\\
	  Ergo, $\tc{H}{l}{\gs}$ as required.
	\item[\textsc{SI-DEREF}]
	  By inversion, $\shallow{\gU}{\lv{x}{p'}}{\refval{q}{\gt}}$ 
	  and $\initShadow{\gt}=\gs$.\\
	  By induction, $\tc{H}{\own{\ga}}{\refval{q}{\gt}}$.\\
	  There are no rules for deriving this.\\
	  Thus, by inversion, this case is impossible.
      \end{itemize}
    \item[\textsc{PE-DEREF}] 
      Then $p = \deref{p'}$.\\
      By inversion, $\ev{V;H}{\lv{x}{p'}}{\addr{\ga'}{r'}}$
      and $\Read{H}{\addr{\ga'}{r'}}{\refval{q}{\addr{\ga}{r}}}$.\\
      There are two possible rules for deriving $\shallow{\gU}{\lv{x}{\deref{p'}}}{\gs}$.
      \begin{itemize}
	\item[\textsc{SI-DEOWN}]
	  By inversion, $\shallow{\gU}{\lv{x}{p'}}{\own{\gs}}$.\\
	  By induction, $\tc{H}{\refval{q}{\addr{\ga}{r}}}{\own{\gs}}$.\\
	  There are no rules for deriving this.\\
	  Thus, by inversion, this case is impossible.
	\item[\textsc{SI-DEREF}]
	  By inversion, $\shallow{\gU}{\lv{x}{p'}}{\refval{q}{\gt}}$ 
	  and $\initShadow{\gt}=\gs$.\\
	  By induction, $\tc{H}{\refval{q}{\addr{\ga}{r}}}{\refval{q}{\gt}}$.\\
	  There is only one rule (\textsc{LS-REF}) for deriving this.\\
	  Thus, by induction, we have $\Read{H}{\addr{\ga}{r}}{l'}$
	  and $\tc{H}{l'}{\initShadow{\gt}}$.\\
	  By Read Uniqueness, we have $l' = l$.\\
	  Ergo, $\tc{H}{l}{\gs}$ as required.
      \end{itemize}
    \item[\textsc{PE-PROJ}] 
      Then $p = \proj{p'}{i}$ and $r = \proj{r'}{i}$.\\
      By inversion, $\ev{V;H}{\lv{x}{p'}}{\addr{\ga}{r'}}$.\\
      There is only one rule (\textsc{SI-PROJ}) for 
      deriving $\shallow{\gU}{\lv{x}{\proj{p'}{i}}}{\gs}$.\\
      Thus, by inversion, we have $\gs=\gs_i$ and
      $\shallow{\gU}{\lv{x}{p'}}{\subrec{\gs}{i}{n}}$.\\
      There is only one rule (\textsc{RD-PROJ}) for 
      deriving $\Read{H}{\addr{\ga}{\proj{r'}{i}}}{l}$.\\
      Thus, by inversion, we have $l=l_i$ and
      $\Read{H}{\addr{\ga}{r'}}{\subrec{l}{i}{n}}$.\\
      By induction, we have $\tc{H}{\subrec{l}{i}{n}}{\subrec{\gs}{i}{n}}$.\\
      There is only one rule (\textsc{LS-REC}) for deriving this.\\
      Thus, by inversion, we have $\tc{H}{l_i}{\gs_i}$ as required.
    \item[\textsc{PE-UNROLL}] 
      Then $p = \unroll{\gt}{p'}$ and $r = \unroll{\gt}{r'}$.\\
      By inversion, $\ev{V;H}{\lv{x}{p'}}{\addr{\ga}{r'}}$.\\
      There is only one rule (\textsc{SI-UNROLL}) for
      deriving $\shallow{\gU}{\lv{x}{\unroll{\gt}{p'}}}{\gs}$.\\
      Thus, by inversion, we have $\shallow{\gU}{\lv{x}{p'}}{\roll{\gt'}{\gs}}$.\\
      There is only one rule (\textsc{RD-UNROLL}) for
      deriving $\Read{H}{\addr{\ga}{\unroll{\gt}{r'}}}{l}$.\\
      Thus, by inversion, we have $\Read{H}{\addr{\ga}{r'}}{\roll{\gt''}{l}}$.\\
      By induction, $\tc{H}{\roll{\gt''}{l}}{\roll{\gt'}{\gs}}$.\\
      There is only one rule (\textsc{LS-ROLL}) for deriving this.\\
      Thus, by inversion, we have $\gt' = \gt'' = \tyfix{X}{\gt'''}$
      and $\tc{H}{l}{\gs}$ required.
  \end{itemize}
\end{proof}

\section*{Path Progress}
Finally, we have all we need to proof path evaluation progress under the right circumstances.
Assuming all our contexts and the heap are well-formed,
then a shallowly initialized, well-typed path can evaluate to some route.
We can then rely on path preservation to show that route has the same type as the path.
Read safety then lets us show that we can read a layout at that route
and that it has the same type. Shadow preservation guarantees us that our
model of the layout reflects reality. All of the key pieces we need for
the higher layers of Patina.

\begin{lem}[Path Progress]
  \raggedright{}
  If $\tc{}{H}{\gS;\gY}$, $\gG;V\vdash\gS$, $\tc{}{\gU}{\gG}$, $\tc{V}{H}{\gU}$,
  $\tc{\gG}{\lv{x}{p}}{\gt}$, and $\shallow{\gU}{\lv{x}{p}}{\gs}$
  then there is some $\addr{\ga}{r}$ such that $\ev{V;H}{\lv{x}{p}}{\addr{\ga}{r}}$.
\end{lem}

\begin{proof}[Path Progress]
  Induction on the derivation of $\tc{\gG}{\lv{x}{p}}{\gt}$.
  \begin{itemize}
    \item[PT-BASE] 
      Then $p = \base$.\\
      By inversion, $\gG(x)=\gt$.\\
      From $\gG;V\vdash\gS$, we have $\gG(x)=\gS(V(x))$.\\
      Ergo, $\exists \ga.~V(x)=\ga$.\\
      Then by \textsc{PE-BASE}, we have $\ev{V;H}{\lv{x}{\base}}{\addr{\ga}{\base}}$.
    \item[PT-DEOWN] 
      Then $p = \deref{p'}$.\\
      By inversion, $\tc{\gG}{\lv{x}{p'}}{\own{\gt}}$.\\
      There are two possible rules for deriving $\shallow{\gU}{\lv{x}{\deref{p'}}}{\gs}$.
      \begin{itemize}
	\item[\textsc{SI-DEOWN}]
	  By inversion, $\shallow{\gU}{\lv{x}{p'}}{\own{\gs}}$.\\
	  By induction, $\exists \addr{\ga}{r}.~\ev{V;H}{\lv{x}{p'}}{\addr{\ga}{r}}$.\\
	  By Path Type Preservation, $\tc{\gS;\gY}{\addr{\ga}{r}}{\own{\gt}}$.\\
	  By Read Safety, $\Read{H}{\addr{\ga}{r}}{l}$ 
	  and $\tc{\gS;\gY}{l}{\own{\gt}}$ for some $l$.\\
	  By Shadow Preservation, $\tc{H}{l}{\own{\gs}}$.\\
	  There is only one rule (\textsc{LS-OWN}) for deriving this.\\
	  Thus, by inversion, we have $l =\ \own{\ga'}$,
	  $\Read{H}{\addr{\ga'}{\base}}{l'}$, and $\tc{H}{l'}{\gs}$.\\
	  Using \textsc{PE-DEOWN} with
	  $\ev{V;H}{\lv{x}{p'}}{\addr{\ga}{r}}$ and
	  $\Read{H}{\addr{\ga}{r}}{\own{\ga'}}$, \\ 
	  we get $\ev{V;H}{\lv{x}{\deref{p'}}}{\addr{\ga'}{\base}}$,
	  which is what was required.
	\item[\textsc{SI-DEREF}]
	  By inversion, $\shallow{\gU}{\lv{x}{p'}}{\refval{q}{\gt}}$.\\
	  By \textsc{shallow} Type Preservation, $\tc{}{\refval{q}{\gt}}{\own{\gt}}$.\\
	  There are no rules for deriving this.\\
	  Thus, by inversion, this case is impossible.
      \end{itemize}

    \item[PT-DEREF] 
      Then $p = \deref{p'}$.\\
      By inversion, $\tc{\gG}{\lv{x}{p'}}{\tyref{\lt}{q}{\gt}}$.\\
      There are two possible rules for deriving $\shallow{\gU}{\lv{x}{\deref{p'}}}{\gs}$.
      \begin{itemize}
	\item[\textsc{SI-DEOWN}]
	  By inversion, $\shallow{\gU}{\lv{x}{p'}}{\own{\gs}}$.\\
	  By \textsc{shallow} Type Preservation, $\tc{}{\own{\gs}}{\tyref{\lt}{q}{\gt}}$.\\
	  There are no rules for deriving this. \\
	  Thus, by inversion, this case is impossible.
	\item[\textsc{SI-DEREF}]
	  By inversion, $\shallow{\gU}{\lv{x}{p'}}{\refval{q}{\gt}}$.\\
	  By induction, $\exists \addr{\ga}{r}.~\ev{V;H}{\lv{x}{p'}}{\addr{\ga}{r}}$.\\
	  By Path Type Preservation, $\tc{\gS;\gY}{\addr{\ga}{r}}{\tyref{\lt}{q}{\gt}}$.\\
	  By Read Safety, $\Read{H}{\addr{\ga}{r}}{l}$ 
	  and $\tc{\gS;\gY}{l}{\tyref{\lt}{q}{\gt}}$ for some $l$.\\
	  By Shadow Preservation, $\tc{H}{l}{\refval{q}{\gt}}$.\\
	  There is only one rule (\textsc{LS-REF}) for deriving this.\\
	  Thus, by inversion, we have $l = \refval{q}{\addr{\ga'}{r'}}$
	  and $\Read{H}{\addr{\ga'}{r'}}{l'}$.\\
	  Using \textsc{PE-DEREF} with 
	  $\ev{V;H}{\lv{x}{p'}}{\addr{\ga}{r}}$ and
	  $\Read{H}{\addr{\ga}{r}}{\refval{q}{\addr{\ga'}{r'}}}$,\\
	  we get $\ev{V;H}{\lv{x}{\deref{p'}}}{\addr{\ga'}{r'}}$,
	  which is what was required.
      \end{itemize}

    \item[PT-PROJ] 
      Then $p = \proj{p'}{i}$ and $\gt=\gt_i$.\\
      By inversion, $\tc{\gG}{\lv{x}{p'}}{\subrec{\gt}{i}{n}}$.\\
      There is only one rule (\textsc{SI-PROJ}) for 
      deriving $\shallow{\gU}{\lv{x}{\deref{p'}}}{\gs}$.\\
      Thus, by inversion, we have $\gs=\gs_i$ 
      and $\shallow{\gU}{\lv{x}{p'}}{\subrec{\gs}{i}{n}}$.\\
      By induction, $\exists \addr{\ga}{r}.~\ev{V;H}{\lv{x}{p'}}{\addr{\ga}{r}}$.\\
      Then by \textsc{PE-PROJ}, we have $\ev{V;H}{\lv{x}{\proj{p'}{i}}}{\addr{\ga}{\proj{r}{i}}}$.
    \item[PT-UNROLL] 
      Then $p = \unroll{\tyfix{X}{\gt'}}{p'}$ and $\gt = \sub{X}{\tyfix{X}{\gt'}}{\gt'}$. \\
      By inversion, $\tc{\gG}{\lv{x}{p'}}{\tyfix{X}{\gt'}}$.\\
      There is only one rule (\textsc{SI-UNROLL}) for 
      deriving $\shallow{\gU}{\lv{x}{\unroll{\tyfix{X}{\gt'}}{p'}}}{\gs}$.\\
      Thus, by inversion, $\shallow{\gU}{\lv{x}{p'}}{\roll{\gt''}{\gs}}$.\\
      By induction, $\exists \addr{\ga}{r}.~\ev{V;H}{\lv{x}{p'}}{\addr{\ga}{r}}$.\\
      Then by \textsc{PE-UNROLL}, we have 
      $\ev{V;H}{\lv{x}{\unroll{\tyfix{X}{\gt'}}{p'}}}{\addr{\ga}{\unroll{\tyfix{X}{\gt'}}{r'}}}$.
  \end{itemize}
\end{proof}
