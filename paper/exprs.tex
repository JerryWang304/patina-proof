\section*{R-Values}

R-values in Patina are expressions that can evaluate to a layout.
This layer of Patina involves the borrow checker, which ensures the borrowed reference guarantees.
In order to focus on the details of the borrow checker, we will pare down our types.
Variants, tuples, and recursive types have straightforward behavior here 
and would unnecessarily clutter the discussion.
Going forward, we will use this subset of our earlier language:

\[
\begin{array}{lccl}
\textrm{Context}  & \gG & : & \textrm{Variable} \rightarrow \textrm{Type} \\
\textrm{Shadow Heap} & \gU & : & \textrm{Variable} \rightarrow \textrm{Shadow} \\
\textrm{Map} & V   & : & \textrm{Variable} \rightarrow \textrm{Allocation} \\
\textrm{Heap Type} & \gS & : & \textrm{Allocation} \rightarrow \textrm{Type} \\
\textrm{Heap} & H   & : & \textrm{Allocation} \rightarrow \textrm{Layout} \\
& & & \\
\textrm{Lifetime} & \lt & & \\
\textrm{Variable} & x & & \\
\textrm{Integer} & z & & \\
\textrm{Allocation} & \ga & & \\
& & & \\
\textrm{Qualifier} & q & \bnfdef & \qimm \bnfalt \qmut \\
\textrm{Type} & \gt & \bnfdef & \tyint \bnfalt \own{\gt} \bnfalt \tyref{\lt}{q}{\gt} \\
\textrm{Path} & p & \bnfdef & \base \bnfalt \deref{p} \\
\textrm{Cell} & c & \bnfdef & \void \bnfalt z \bnfalt \own{\ga} \bnfalt \refval{q}{\ga} \\
\textrm{Layout} & l & \bnfdef & c \\
\textrm{Hole} & h & \bnfdef & \uninit \bnfalt \tyint \bnfalt \own{\gs} \bnfalt \refval{q}{\gt} \\
\textrm{Shadow} & \gs & \bnfdef & h \\
\end{array}
\]

Routes would only consist of $\base$, so they are now elided.
Without variants, the $\gY$ context is irrelevant, so it is elided as well.

We define three kinds of expressions: integer constants, using the value at an L-value, 
and creating a borrowed reference to the value at an L-value.

\[
\begin{array}{lccl}
\textrm{Expression} & e & \bnfdef & z \bnfalt \lv{x}{p} \bnfalt \tyref{\lt}{q}{\lv{x}{p}}
\end{array}
\]

\subsection*{Tracking Loans\footnotemark}

\footnotetext {
Rust itself and earlier models of Patina used a dramatically different form
of loan tracking and borrow checking. A universal set of loans is kept and threaded
through the type checker. Each loan generates a set of paths that cannot be accessed
without violating a loan guarantee. The borrow checker would then make sure that
no path used was in that set of forbidden paths.

This structure does not lend itself to proofs, so we devised this alternate system.
The system we present below is syntax driven and, we think, easier to understand.
Since proving this system matches the original would run into the problem we tried
to avoid in the first place, we satisfied ourselves with testing the two implementations.
The original model and this model agree on all the tests used in the original model.
}

When we use an L-value in an expression, we must ensure the operation we are performing on it
does not violate the promises of existing loans, and we must ensure that the value it refers
to is fully initialized. When we create a borrowed reference, we must ensure that the
promises of the borrow can actually be upheld for the duration of the borrow.
In order to make these checks, we need to know what is borrowed, how it is borrowed, and for
how long it is borrowed. We will accomplish this by adding a stack of loans to every
level of the shadow heap:

\[
\begin{array}{lccl}
\textrm{Hole} & h & \bnfdef & \uninit \bnfalt \tyint \bnfalt \own{\gs} \bnfalt \refval{q}{\gs} \\
\textrm{Bank} & \$ & \bnfdef & \emptyset \bnfalt \$, (\lt,q) \\
\textrm{Shadow} & \gs & \bnfdef & \$:h \\
\end{array}
\]

Each pair $(\lt, q)$ describes the duration and manner of a loan, 
with more recent loans at the front of the stack.
Since every path can be borrowed, every path must have a loan stack (or bank) associated with it.
The easiest way to do that is to tag every shadow with a bank.
Note that the borrowed reference hole has changed.
When we only cared about initialization, we used the hole $\refval{q}{\gt}$.
Since everything reachable via the borrow was initialized, we did not need to record
the initialization state.
Now, however, we do need to record the loan state of things reachable via the borrow.
Thus, we make the reference hole recursive: $\refval{q}{\gs}$.

\subsection*{Shadow Typing with Banks}
Since our shadows now include loan information, we need to modify our shadow typing.
While we have included lifetimes in our model from the beginning, this is the first time
we will actually utilize them. Before we can discuss how to check banks, we must first
discuss what lifetimes are, where they come from, and what they give us.

\subsubsection*{The Lifetime Relation}
Lifetimes, as the name implies, encompass a notion of duration.
Specifically, they describe the duration a value is allocated and 
the duration of a loan. Each new block of scope defines a new lifetime.
So there is a clear ordering on lifetimes, $\lt \leq \lt'$ if the duration of $\lt$
is not longer than the duration of $\lt'$. More formally:

$$ \ltr \subseteq \textrm{Lifetime} \times \textrm{Lifetime} $$

$$ \infer{\ltr \ \textrm{is a poset}}{\vdash \ltr} $$

where $(\lt, \lt') \in \ltr$ means $\lt \leq \lt'$. Rust allows some other sources of lifetimes
not relevant to the current model: lifetime parameters for functions and \emph{static}, which
is the oldest lifetime and typically used for string constants. Though the lifetimes in our
model form a total order, the general Rust lifetime relation is only a partial order.
Since we intend this model to be a potential basis for all of Rust, we will ignore the
totality of our lifetimes.

\subsubsection*{Bank Coherence}
As mentioned before, lifetimes come from scope blocks.
This means that every variable has a lifetime, which comes from the block it was defined in.
Since variables are deallocated at the end of the block in which they are defined,
that lifetime is an accurate model. We record the lifetimes of variables in a new context:

$$ L : \textrm{Variable} \rightarrow \textrm{Lifetime} $$

Furthermore, if variables only exist for a particular lifetime, then it makes sense that
loans of memory owned by the variable cannot be longer than the lifetime of the variable.
Otherwise the deallocation of the variable could create dangling pointers elsewhere.

Finally, we must ensure that more recent loans are not inconsistent with older loans
of the same path. If a path is already loaned out for some lifetime $\lt$ and
we loan it out again for some lifetime $\lt'$, then $(\lt', \lt) \in \ltr$.
A loan only controls a value during the loan's lifetime, so it cannot make promises
for lifetimes longer than that. Additionally, given a mutable loan we can reloan it immutably,
but not the other way. A mutable loan knows it has unique access to a value, so it can
guarantee the value can be immutable if it wishes. On the other hand, an immutable loan
promises that the value will not be changed for its duration, which violates the requirement
that a mutable loan should be able to mutate its referent. We characterize this relationship
with an ordering on qualifiers: $\qimm < \qmut$.
\newline

\fbox{$\bankwf{\ltr}{\$}{\lt}$}

\begin{mathpar}
\infer[BWF-NONE]{ }{\bankwf{\ltr}{\emptyset}{\lt}} \and
\infer[BWF-ONE]{(\lt', \lt) \in \ltr}{\bankwf{\ltr}{\emptyset , (\lt', q)}{\lt}} \and
\infer[BWF-TWO]
  {(\lt_2, \lt_1) \in \ltr \\ q_2 \leq q_1 \\ \bankwf{\ltr}{\$, (\lt_1, q_1)}{\lt}}
  {\bankwf{\ltr}{\$,(\lt_1, q_1), (\lt_2, q_2)}{\lt}} \and
\end{mathpar}

\subsubsection*{Bounded Shadow Typing}
We need to update our shadow typing judgment to support checking bank coherence,
but we need to check two new things as well. First, we will require that
variables can only reference memory that they will not outlast. This means
we require borrowed references to have lifetimes not shorter than the bounding lifetime,
which is the reverse of the requirement on loans. This should make sense, we can only use
memory that will exist at least as long as us, but we can only loan out our memory
to others that will not last longer than us.

Second, we need to make sure that more specific loans do not contradict more general loans.
For example, if a variable $x$ is loaned immutably, then a mutable loan of $\deref{x}$
would not make sense. The immutable loan of $x$ promises that no memory reachable via $x$
will change, but the mutable loan of $\deref{x}$ promises that the memory reachable 
via $\deref{x}$ can be changed through the borrowed reference. Similarly, if $x$ was loaned
mutably, then $\deref{x}$ could not be loaned at all. The loan of $x$ promises that only
the borrowed reference has access to memory reachable from $x$, but the loan of $\deref{x}$
creates an alias to part of that memory. In general, a wider immutable loan requires more
specific loans to not be mutable loans, and a wider mutable loan prevents any more specific
loans.

\[
\begin{array}{lccl}
\textrm{Maybe Qualifier} & mq & \bnfdef & \mqnone \bnfalt q
\end{array}
\]

\fbox{$\nm{\$}$}

\begin{mathpar}
  \infer[NM-EMPTY]{ }{\nm{\emptyset}} \and
  \infer[NM-IMM]{ }{\nm{\$, (\lt, \qimm)}}
\end{mathpar}

\fbox{$\tcb{\ltr}{\gs}{\gt}{mq}{\lt}$}

\begin{mathpar}
  \infer[ST-NONE]
    {\bankwf{\ltr}{\emptyset}{\lt} \\ \tcb{\ltr}{h}{\gt}{\mqnone}{\lt}}
    {\tcb{\ltr}{(\emptyset : h)}{\gt}{\mqnone}{\lt}} \and
  \infer[ST-SOME]
    {\bankwf{\ltr}{\$,(\lt',q)}{\lt} \\ \tcb{\ltr}{h}{\gt}{q}{\lt}}
    {\tcb{\ltr}{(\$,(\lt',q) : h)}{\gt}{\mqnone}{\lt}} \and
  \infer[ST-IMM]
    {\bankwf{\ltr}{\$}{\lt} \\ \nm{\$} \\ \tcb{\ltr}{h}{\gt}{\qimm}{\lt}}
    {\tcb{\ltr}{(\$ : h)}{\gt}{\qimm}{\lt}} \and
  \infer[ST-MUT]
    {\bankwf{\ltr}{\emptyset}{\lt} \\ \tcb{\ltr}{h}{\gt}{\qmut}{\lt}}
    {\tcb{\ltr}{(\emptyset : h)}{\gt}{\qmut}{\lt}}
\end{mathpar}

\fbox{$\tcb{\ltr}{h}{\gt}{mq}{\lt}$}

\begin{mathpar}
  \infer[HT-UNINT]{ }{\tcb{\ltr}{\uninit}{\tyint}{mq}{\lt}} \and
  \infer[HT-UNOWN]{ }{\tcb{\ltr}{\uninit}{\own{\gt}}{mq}{\lt}} \and
  \infer[HT-UNREF]{(\lt,\lt')\in\ltr}{\tcb{\ltr}{\uninit}{\tyref{\lt'}{q}{\gt}}{mq}{\lt}} \and
  \infer[HT-INT]{ }{\tcb{\ltr}{\tyint}{\tyint}{mq}{\lt}} \and
  \infer[HT-OWN]{\tcb{\ltr}{\gs}{\gt}{mq}{\lt}}{\tcb{\ltr}{\own{\gs}}{\own{\gt}}{mq}{\lt}} \and
  \and
  \infer[HT-REFMUT]
    {(\lt, \lt') \in \ltr \\ \tcb{\ltr}{\gs}{\gt}{mq}{\lt} \\ \gs\ \textrm{init}}
    {\tcb{\ltr}{\refval{\qmut}{\gs}}{\tyref{\lt'}{\qmut}{\gt}}{mq}{\lt}}
  \and
  \infer[HT-REFIMM]
    {(\lt, \lt') \in \ltr \\ \tcb{\ltr}{\gs}{\gt}{\qimm}{\lt} \\ \gs\ \textrm{init}}
    {\tcb{\ltr}{\refval{\qimm}{\gs}}{\tyref{\lt'}{\qimm}{\gt}}{mq}{\lt}}


\end{mathpar}

where ``$\gs\ \textrm{init}$'' in HT-REFMUT and HT-REFIMM is a judgment 
that ensures a shadow is fully initialized,
i.e.\ it cannot reach a $\uninit$.
Note that the interior of immutable borrowed references is always controlled
by an immutable loan. This prevents mutable loans of the interior of immutable borrows,
which are nonsensical.

\subsubsection*{Bounded Shadow Heap Well-Formedness}
With our shadow typing updated to check banks,
we can update what we mean by a well-formed shadow heap.
The lifetime relation and the lifetime map are now included.
We ensure the lifetime map is well-formed by requiring its domain to be
the same as the domain of the type context and the shadow heap, and by requiring
that every lifetime in its range to be in the lifetime relation.

\begin{mathpar}
\mprset{flushleft}
\infer{
\dom \gG = \dom \gU = \dom L \\\\
\forall x \in \dom \gG.~\gG(x)~\textrm{closed} \\\\
\forall x \in \dom L.~(L(x),L(x)) \in L \\\\
\forall x \in \dom \gU.~\tcb{\ltr}{\gU(x)}{\gG(x)}{\mqnone}{L(x)}
}
{\tb{\ltr}{\gU}{\gG}{L}}
\end{mathpar}

\subsection*{Ensuring Operations Do Not Violate Loans}
The most important duty of the borrow checker is making sure that
performing some operation does not violate the promises of existing loans.
We cannot read a path that has promised unique access to another.
We cannot write to a path that has promised to remain unchanged or that we cannot read.
We cannot move from a path that we do not own or that we cannot write.

Additionally, we can only use a path that is fully initialized, or our program might
try to touch an uninitialized value and get stuck.
This means that $\shallow{\gU}{\lv{x}{p}}{\gs}$ holds and that $\gs\ \textrm{init}$ holds. 
That is, enough memory is initialized to evaluate the L-value to a memory location,
and everything reachable from that location is initialized.
We use these dual judgments as a base to define our validity 
checks for reading, writing, and moving.
Reading will be more restricted than simple full initialization.
Writing will be more restricted than reading.
Moving will be more restricted than writing.

\subsubsection*{Reading}
The restriction we add to full initialization to verify that reading a path is valid is
that no part of the path or anything reachable from the path has been mutable loaned.
A mutable loan promises unique access via the corresponding mutable borrowed reference, 
which precludes reading the loaned path directly.
We can also short-circuit our check in a two cases.
If the path we want to read dereferences an immutable borrow, then we do not need
to check the interior of the borrow. By its nature, the immutable borrow guarantees readability,
and any mutable loaning of the interior is already forbidden.
For similar reasons, when checking the memory reachable from the path 
we do not need to examine the interior of immutable borrows.
\newline

\fbox{$\cnml{\gs}$}

\begin{mathpar}
  \infer[CNML-INT]{\nm{\$}}{\cnml{\$:\tyint}} \and
  \infer[CNML-OWN]{\nm{\$} \\ \cnml{\gs}}{\cnml{\$:\own{\gs}}} \and
  \infer[CNML-REFIMM]{\nm{\$}}{\cnml{\$:\refval{\qimm}{\gs}}} \and
  \infer[CNML-REFMUT]{\nm{\$} \\ \cnml{\gs}}{\cnml{\$:\refval{\qmut}{\gs}}}
\end{mathpar}

\fbox{$\canread{p}{\gs}$}

\begin{mathpar}
  \infer[CR-BASE] {\cnml{\gs}} {\canread{\base}{\gs}} \and
  \infer[CR-DEOWN]
    {\nm{\$} \\ \canread{p}{\gs} }
    {\canread{\deref{p}}{\$:\own{\gs}}} \and
  \infer[CR-DEREFIMM]
    {\nm{\$}}
    {\canread{\deref{p}}{\$:\refval{\qimm}{\gs}}} \and
  \infer[CR-DEREFMUT]
    {\nm{\$} \\ \canread{p}{\gs}}
    {\canread{\deref{p}}{\$:\refval{\qmut}{\gs}}}
\end{mathpar}

where one would check that $\lv{x}{p}$ is readable by $\canread{p}{\gU(x)}$.

\subsubsection*{Writing}
In order to safely write a path, no part of the path or anything reachable from the path
can be loaned at all. An immutable loan implies the data is frozen, 
which prevents us from writing. A mutable loan implies something else has unique acces
to the data, which also prevents us from writing.
Additionally, we cannot write to the interior of an immutable borrow, even if we can
write to the borrowed reference itself. Memory reachable from that immutable borrow
is frozen.
\newline

\fbox{$\cnl{\gs}$}

\begin{mathpar}
  \infer[CNL-INT]{ }{\cnl{\emptyset : \tyint}} \and
  \infer[CNL-OWN]{\cnl{\gs}}{\cnl{\emptyset : \own{\gs}}} \and
  \infer[CNL-REF]{\cnl{\gs}}{\cnl{\emptyset : \refval{q}{\gs}}}
\end{mathpar}

Note that the borrowed reference cases of have merged again after being separate for reading.
We cannot guarantee that the interior of an immutable borrow will not be loaned out without
actually checking. However, note that $\cnl{\gs}$ implies $\cnml{\gs}$.
\newline

\fbox{$\cw{p}{\gs}$}

\begin{mathpar}
  \infer[CW-BASE]{\cnl{\gs}}{\cw{\base}{\gs}} \and
  \infer[CW-DEOWN]{\cw{p}{\gs}}{\cw{\deref{p}}{\emptyset : \own{\gs}}} \and
  \infer[CW-DEREFMUT]{\cw{p}{\gs}}{\cw{\deref{p}}{\emptyset : \refval{\qmut}{\gs}}}
\end{mathpar}

Again, note that $\cw{p}{\gs}$ implies $\canread{p}{\gs}$.
Rust requires that the ability to write implies the ability to read, which is
reflected in our judgments.

\subsubsection*{Moving}
The final operation, moving out of a path, requires ownership over the path.
Moving is used when the value being read has an affine type, which prevents it 
from being merely copied. The old location of the value must be purged.
This requires the ability to write, but since it leaves the original path uninitialized
it cannot be used via mutable borrows. Doing so would violate the guarantee that borrowed
references always point to initialized memory.
\newline

\fbox{$\cm{p}{\gs}$}

\begin{mathpar}
  \infer[CM-BASE]{\cnl{\gs}}{\cm{\base}{\gs}} \and
  \infer[CM-DEOWN]{\cm{p}{\gs}}{\cm{\deref{p}}{\emptyset : \own{\gs}}}
\end{mathpar}

Note that $\cm{p}{\gs}$ implies $\cw{p}{\gs}$.

\subsection*{Affine Types and Copyability}
Values of an affine type cannot be used more than once, e.g.\ unique pointers.
We model this in Patina by deinitializing an affine value on use.
However, we do not want to do this unnecessarily so we need to distinguish between
affine and non-affine types. Affine types must be moved, 
but non-affine types can be merely copied.
In Patina, unique pointers and borrowed mutable references are the sources of affineness.
Unique pointers must be affine to preserve their uniqueness.
Borrowed mutable references must be affine to preserve the unique access they promise.
\newline

\fbox{$\tycopy{\gt}$}

\begin{mathpar}
  \infer[C-INT]{ }{\tycopy{\tyint}} \and
  \infer[C-REFIMM]{ }{\tycopy{\tyref{\lt}{\qimm}{\gt}}}
\end{mathpar}

\fbox{$\tymove{\gt}$}

\begin{mathpar}
  \infer[M-OWN]{ }{\tymove{\own{\gt}}} \and
  \infer[M-REFMUT]{ }{\tymove{\tyref{\lt}{\qmut}{\gt}}}
\end{mathpar}

The two judgments here are not particularly interesting without compound types,
but they still create a necessary distinction.
Note that these two judgments partition the set of types.

\subsection*{Using an L-value}
Now that we can check that an operation is safe and we can determine from the type
which operation to perform, we can specify how to check that using the value at an L-value 
is safe and track how doing so changes the shadow heap.
\newline

\fbox{$\uselv{\gG}{\gU}{\lv{x}{p}}{\gt}{\gU'}$}

\begin{mathpar}
  \infer[UP-COPY]
    {\tc{\gG}{\lv{x}{p}}{\gt} \\ \tycopy{\gt} \\ \canread{p}{\gU(x)}}
    {\uselv{\gG}{\gU}{\lv{x}{p}}{\gt}{\gU}}
  \and
  \infer[UP-MOVE]
    {\tc{\gG}{\lv{x}{p}}{\gt} \\ \tymove{\gt} \\ \cm{p}{\gU(x)} 
    \\ \textsc{use}(\gU,\lv{x}{p},\gU') }
    {\uselv{\gG}{\gU}{\lv{x}{p}}{\gt}{\gU'}}
\end{mathpar}

where $\textsc{use}(\gU,\lv{x}{p},\gU')$ modifies the shadow 
of $\lv{x}{p}$ to deinitialize the affine values.

\begin{conj}[L-Value Use Shadow Preservation]
  If $\vdash\ltr$, $\tb{\ltr}{\gU}{\gG}{L}$, and $\uselv{\gG}{\gU}{\lv{x}{p}}{\gt}{\gU'}$
  then $\tb{\ltr}{\gU'}{\gG}{L}$.
\end{conj}

\begin{proof}[Justification]
  Using a path either leaves the shadow heap unchanged or deinitializes only a part of it,
  neither of which should change the types of shadows or the lifetimes of loans.
  Deinitializing part of the shadow heap could invalidate existing loans,
  but the \textsc{can-read} and \textsc{can-move} checks should rule out those cases.
\end{proof}

\subsection*{Ensuring Loan Promises Can Be Upheld}
When creating a borrowed reference, the borrow checker must ensure
that is it actually possible to make the promises that the loan demands.
For example, we cannot promise the interior of a borrowed reference will be 
valid for longer than that reference's lifetime, nor can we promise that
the interior of a immutable borrowed reference will have unique access.

\subsubsection*{Validity}
Both kinds of borrowed references require that their referent be initialized for
the lifetime of the reference, which here we call \emph{validity}.
Variables are valid for their entire lifetime and can be loaned out for any duration
not longer than that.
Unique pointers inherit the lifetime of their owner.
Borrowed references specify how long they are valid by their lifetime, and they
can be loaned out for any duration not longer than that. Since we already know
the interior of a borrowed reference is valid for the lifetime of that reference,
we do not need to examine further.
\newline

\fbox{$\valid{\gG}{\ltr}{L}{\lv{x}{p}}{\lt}$}

\begin{mathpar}
  \infer[VF-BASE]{(\lt,L(x))\in\ltr}{\valid{\gG}{\ltr}{L}{\lv{x}{\base}}{\lt}} \and
  \infer[VF-DEOWN]
    {\tc{\gG}{\lv{x}{p}}{\own{\gt}} \\ \valid{\gG}{\ltr}{L}{\lv{x}{p}}{\lt}}
    {\valid{\gG}{\ltr}{L}{\lv{x}{\deref{p}}}{\lt}} \and
  \infer[VF-DEREF]
    {\tc{\gG}{\lv{x}{p}}{\tyref{\lt'}{q}{\gt}} \\ (\lt,\lt')\in\ltr}
    {\valid{\gG}{\ltr}{L}{\lv{x}{\deref{p}}}{\lt}}
\end{mathpar}

\subsubsection*{Uniqueness}
Mutable loans require the loaned memory have \emph{unique} access.
If the path being loaned has unique access, then it can give that access to the 
new mutable borrow.
Variables, being top level, are inherently unique along with unique pointers.
Mutable borrows provide unique access to their interiors for their duration.
Immutable borrows are inherently not unique.
\newline

\fbox{$\unique{\gG}{\ltr}{\lv{x}{p}}{\lt}$}

\begin{mathpar}
  \infer[UF-BASE]{ }{\unique{\gG}{\ltr}{\lv{x}{\base}}{\lt}} \and
  \infer[UF-DEOWN]
    {\tc{\gG}{\lv{x}{p}}{\own{\gt}} \\ \unique{\gG}{\ltr}{\lv{x}{p}}{\lt}}
    {\unique{\gG}{\ltr}{\lv{x}{\deref{p}}}{\lt}} \and
  \infer[UF-DEREFMUT]
    {\tc{\gG}{\lv{x}{p}}{\tyref{\lt'}{\qmut}{\gt}} \\ (\lt,\lt')\in\ltr
    \\ \unique{\gG}{\ltr}{\lv{x}{p}}{\lt}}
    {\unique{\gG}{\ltr}{\lv{x}{\deref{p}}}{\lt}}
\end{mathpar}

\subsubsection*{Freezability}
Immutable loans require the loaned memory to be \emph{frozen}, 
unchangable by anything, for the duration of the loan.
When creating an immutable borrow, we need to check a slightly weaker property:
\emph{freezable}, unchangable by anything \emph{else}.
A freezable path can be mutated, but only by the path itself.
If the path does not mutate itself, e.g.\ by loaning itself immutably, then we know it is frozen.
Unique paths are inherently freezable since no other path exists.
Dereferencing through an immutable borrow, while not unique, is freezable because
the interior of the borrow is already guaranteed to be frozen for its lifetime.
\newline

\fbox{$\freezable{\gG}{\ltr}{\lv{x}{p}}{\lt}$}

\begin{mathpar}
  \infer[FF-BASE]{ }{\freezable{\gG}{\ltr}{\lv{x}{\base}}{\lt}} \and
  \infer[FF-DEOWN]
    {\tc{\gG}{\lv{x}{p}}{\own{\gt}} \\ \freezable{\gG}{\ltr}{\lv{x}{p}}{\lt}}
    {\freezable{\gG}{\ltr}{\lv{x}{\deref{p}}}{\lt}} \and
  \infer[FF-DEREFMUT]
    {\tc{\gG}{\lv{x}{p}}{\tyref{\lt'}{\qmut}{\gt}} \\ (\lt,\lt')\in\ltr 
    \\ \freezable{\gG}{\ltr}{\lv{x}{p}}{\lt}}
    {\freezable{\gG}{\ltr}{\lv{x}{\deref{p}}}{\lt}} \and
  \infer[FF-DEREFIMM]
    {\tc{\gG}{\lv{x}{p}}{\tyref{\lt'}{\qimm}{\gt}} \\ (\lt,\lt')\in\ltr }
    {\freezable{\gG}{\ltr}{\lv{x}{\deref{p}}}{\lt}}
\end{mathpar}

Note how $\unique{\gG}{\ltr}{\lv{x}{p}}{\lt}$ implies $\freezable{\gG}{\ltr}{\lv{x}{p}}{\lt}$.
This implies that anything we can borrow mutably we can also borrow immutably,
which accurately reflects Rust.

\subsection*{Expression Typing}
With our model of the borrow checker in hand, we can finally specify the typing of expressions.
\newline

\fbox{$\tc{\gG;\ltr;L;\gU}{e}{\gt;\gU'}$}
\newline

Integer constants are trivial and do not change the shadow heap.

\begin{mathpar}
  \infer[ET-INT]{ }{\tc{\gG;\ltr;L;\gU}{z}{\tyint;\gU}}
\end{mathpar}

Using the value at an L-value simply relies on our earlier judgment.

\begin{mathpar}
  \infer[ET-USE]
    {\uselv{\gG}{\gU}{\lv{x}{p}}{\gt}{\gU'}}
    {\tc{\gG;\ltr;L;\gU}{\lv{x}{p}}{\gt;\gU'}}
\end{mathpar}

Creating an immutable borrowed reference requires checking that the immutable loan
guarantees will be upheld for the entire duration of the loan.
This involves checking that we can read the L-value now, and that we can guarantee
its validity and freezability for the duration of the loan.
We record the new loan in the output shadow heap.

\begin{mathpar}
  \infer[ET-REFIMM]
    {\tc{\gG}{\lv{x}{p}}{\gt} \\
     \canread{p}{\gU(x)} \\
     \valid{\gG}{\ltr}{L}{\lv{x}{p}}{\lt} \\
     \freezable{\gG}{\ltr}{\lv{x}{p}}{\lt} \\
     \textsc{record}(\gU,\lv{x}{p},(\lt,\qimm),\gU')
    }
    {\tc{\gG;\ltr;L;\gU}{\tyref{\lt}{\qimm}{\lv{x}{p}}}{\tyref{\lt}{\qimm}{\gt};\gU'}}
\end{mathpar}

Similarly, creating a mutable borrowed reference requires checking the mutable loan
guarantees. Instead of reading, we must be able to write. Instead of freezability,
we require uniqueness.

\begin{mathpar}
  \infer[ET-REFMUT]
  {\tc{\gG}{\lv{x}{p}}{\gt} \\
   \cw{p}{\gU(x)} \\
   \valid{\gG}{\ltr}{L}{\lv{x}{p}}{\lt} \\
   \unique{\gG}{\ltr}{\lv{x}{p}}{\lt} \\
   \textsc{record}(\gU,\lv{x}{p},(\lt,\qmut),\gU')
  }
  {\tc{\gG;\ltr;L;\gU}{\tyref{\lt}{\qmut}{\lv{x}{p}}}{\tyref{\lt}{\qmut}{\gt};\gU'}}
\end{mathpar}

\begin{conj}[Expression Shadow Preservation]
  If $\vdash\ltr$, $\tb{\ltr}{\gU}{\gG}{L}$, and $\tc{\gG;\ltr;L;\gU}{e}{\gt;\gU'}$
  then $\tb{\ltr}{\gU'}{\gG}{L}$.
\end{conj}

\begin{proof}[Justification]
  This is trivial in the integer case and follows from L-Value Use Shadow Preservation
  in the L-value use case, so we only need to discuss the borrow creation cases.
  In both borrow creation cases, the only change to the shadow heap is the addition of
  one new loan.

  When creating an immutable borrow, we know from \textsc{can-read} that
  no mutable loan exists on way to the path we are borrowing or in memory reachable from it.
  The shadow of the interior of the loaned path is now controlled by the immutable loan
  of the path, but since there were no mutable loans there before and it has not changed
  it should still be well-formed. Similarly, the shadows on the way to the path have not changed
  directly and they should not be affected by the addition of an immutable loan in their
  interior. The main concern is whether the addition of the new immutable loan to the bank 
  will result in a well-formed bank. We know from the validity check that the lifetime
  of the loan is within the lifetime bound of the bank. If the bank is empty or
  the lifetime of the old loan is not shorter than the lifetime of the new loan, then
  the bank will still be well-formed. We could restrict \textsc{record} to only succeed
  in this situation.

  When creating a mutable borrow, we know from \textsc{can-write} that
  no loan exists on the way to the path or in memory reachable from it.
  So similar to the immutable case, the shadow of the interior of the path will still
  be well-formed even though it is now controlled by a mutable loan.
  The shadows on the way to the path are still well-formed since they have no loans to begin with.
  As before, the only question is whether the bank of the path will remain well-formed.
  We know from \textsc{can-write} that the bank is empty, so the new bank, consisting of
  just one mutable loan, will be well-formed.
\end{proof}

\subsection*{Using a Layout}
The runtime analogue of using an L-value is using a layout.
Affine values are replaced by void and copyable values are left untouched.
It is not defined for $\void$, which prevents expression evalutation from utilizing
uninitialized memory. A program that tries to do so will get stuck.
\newline

\fbox{$\textsc{use} : \textrm{Layout} \to \textrm{Layout}$}

\[
\begin{array}{lcl}
\textsc{use}(z) &=& z \\
\textsc{use}(\own{\ga}) &=& \void \\
\textsc{use}(\refval{\qimm}{\ga}) &=& \refval{\qimm}{\ga} \\
\textsc{use}(\refval{\qmut}{\ga}) &=& \void
\end{array}
\]

Note that $\textsc{use}(l) = l'$ implies $\textsc{droppable}(l')$.
Once we use a value, we know we can safely deallocate it.

\subsection*{Expression Evaluation}
Evaluating expressions is straightforward.
The only unusual aspect is the case of using the value at an L-value.
To prevent copies of affine values, we must overwrite the original value
with the used version. If it is a copyable value, then it will remain unchanged.
If it is an affine value, then it will be replaced with $\void$.
Note that this means the heap resulting from expression evaluation is either
unchanged or a more deinitialized version of the starting heap.
Also note that the result heap may temporarily contain a leak when considered alone,
but not when considered together with the result layout.
\newline

\fbox{$\ev{V;H}{e}{l;H'}$}

\begin{mathpar}
  \infer[EE-INT]{ }{\ev{V;H}{z}{z;H}} \and
  \infer[EE-REF]
    {\ev{V;H}{\lv{x}{p}}{\ga}}
    {\ev{V;H}{\tyref{\lt}{q}{\lv{x}{p}}}{\refval{q}{\ga};H}} \and
  \infer[EE-USE]
    {\ev{V;H}{\lv{x}{p}}{\ga} \\
     \Read{H}{\ga}{l} \\
     \textsc{write}(H,\ga,\textsc{use}(l),H')
    }
    {\ev{V;H}{\lv{x}{p}}{l;H'}}
\end{mathpar}

\subsection*{Expression Preservation}
Having defined both evaluation and typing for expressions, we can finally
state the preservation lemma for expressions. Assuming all input contexts are
well-formed and given a well typed expression that evaluates to a layout,
then that layout has the same type as the expression, the resulting shadow heap
is well-formed, and the resulting heap is consistent with the resulting shadow heap.

\begin{conj}[Expression Preservation]
  \raggedright
  If $\tc{}{H}{\gS}$, $\gG;V\vdash\gS$, $\vdash\ltr$, $\tb{\ltr}{\gU}{\gG}{L}$, 
  $\tc{V}{H}{\gU}$, $\tc{\gG;\ltr;L;\gU}{e}{\gt;\gU'}$, and $\ev{V;H}{e}{l;H'}$
  then $\tc{\gS}{l}{\gt}$, $\tc{}{H'}{\gS}$, $\tb{\ltr}{\gU'}{\gG}{L}$, and $\tc{V}{H'}{\gU'}$.
\end{conj}

\begin{proof}[Justification]
  This is trivial in the integer case.
  In the reference case, the heap does not change.
  From Expression Shadow Preservation, we get the well-formedness of the new shadow heap,
  which has been extended with one new loan. Since the intialization information in the shadow
  heap has not changed, it should still model the heap correctly.
  That the type of the layout matches the type of the expression is simple to establish.

  In the use case, we again get the well-formedness of the new shadow heap from
  Expression Shadow Preservation. The type of the layout we can get via 
  Path Type Preservation and Read Safety. The write we perform on the heap
  does not change the type of anything, so the new heap will still typecheck under the heap type.
  In the new shadow heap, the used path was deinitialized (if affine).
  In the new heap, the used path was voided (if affine).
  The new heap should be consistent with the new shadow heap.
\end{proof}

\subsubsection*{The Layout Resulting from Evaluation is Fully Initialized}
We should also note that the resulting layout is fully initialized.
This is trivial in the integer case. In the reference and the use case
we rely on typing judgments that asserted full initialization and the correspondence
of the shadow heap with the runtime heap.

\subsection*{Expression Progress}
The progress lemma for expressions is surprisingly straightforward.
Since we do not nest expressions, no induction is necessary.
Each case constructs the resulting values in a straightforward manner.

\begin{conj}[Expression Progress]
  \raggedright
  If $\tc{}{H}{\gS}$, $\gG;V\vdash\gS$, $\vdash\ltr$, $\tb{\ltr}{\gU}{\gG}{L}$,
  $\tc{V}{H}{\gU}$, and $\tc{\gG;\ltr;L;\gU}{e}{\gt;\gU'}$
  then there exists a layout $l$ and a heap $H'$ such that $\ev{V;H}{e}{l;H'}$.
\end{conj}

\begin{proof}[Justification]
  In the integer case this is trivial.
  In both reference cases, we can rely on Path Progress to evaluate the L-value
  and use the address to construct the resulting layout, and the heap does not change.
  In the use case, we can rely on Path Progress to evaluate the L-value to an address.
  Then we can rely on Read Safety to find the layout. Since we could read sufficiently,
  we can also write sufficiently so we find the heap.

\end{proof}
