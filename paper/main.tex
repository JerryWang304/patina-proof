\documentclass{article}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{float}
\usepackage{amsthm}

\DeclareMathOperator{\dom}{dom}
\begin{document}

\newcommand{\imm}{\textrm{imm}}
\newcommand{\mut}{\textrm{mut}}
\newcommand{\zah}{\textrm{int}}
\newcommand{\pay}{\textrm{pay}}
\newcommand{\unroll}{\textrm{unroll}}
\newcommand{\roll}{\textrm{roll}}
\newcommand{\void}{\textrm{void}}
\newcommand{\slot}{\textrm{slot}}
\newcommand{\uninit}{\textrm{uninit}}
\newcommand{\hole}{\textrm{hole}}

\newcommand{\Own}[1]{\sim {#1}}
\newcommand{\Ref}[3]{\&\ {#1}\ {#2}\ {#3}}
\newcommand{\Var}[2]{\langle {#1} \rangle_{#2}}
\newcommand{\Rec}[2]{[ {#1} ]_{#2}}
\newcommand{\Fix}[2]{\mu {#1}.{#2}}

\newcommand{\Base}{\cdot}
\newcommand{\Deref}[1]{*\ {#1}}
\newcommand{\Proj}[3]{{#1}\cdot_{#2} {#3}}
\newcommand{\Pay}[1]{\pay\ {#1}}
\newcommand{\Unroll}[2]{\unroll\ [{#1}]\ {#2}}

\newcommand{\OwnVal}[2]{\Own{{#1}\ {#2}}}
\newcommand{\Slot}[1]{\slot\ {#1}}
\newcommand{\VarVal}[3]{\langle {#1} : {#2} \rangle_{#3}}
\newcommand{\Roll}[2]{\roll\ [{#1}]\ {#2}}

\newcommand{\RefVal}[2]{\&\ {#1}\ {#2}}
\newcommand{\Hole}[1]{\hole\ {#1}}

\newcommand{\Subst}[3]{[{#1} \mapsto {#2}]{#3}}

\newcommand{\Type}[3]{{#1} \vdash {#2} : {#3}}
\newcommand{\RTType}[4]{\Type{{#1} ;{#2}}{{#3}}{{#4}}}
\newcommand{\ARType}[5]{\RTType{{#1}}{{#2}}{{#3}\ {#4}}{{#5}}}
\newcommand{\Read}[4]{\textsc{read}({#1},{#2},{#3},{#4})}
\newcommand{\HWF}[3]{\vdash {#1} : {#2} ; {#3}}

\section{Syntax}

TODO describe Lifetime in more detail (values vs variables, the relation etc).

\begin{figure}[H]
  $\ell \in $ Lifetime

  $x \in $ Variable

  $\alpha \in $ Allocation

  $z \in $ Integer

  $X \in $ Type Variable

  $i,n \in $ Natural
  \caption{Sets}
\end{figure}

\begin{figure}[H]
  Qual $q ::= \imm{}\ |\ \mut{}$

  Type $\tau ::= \zah{}\ |\ \Own{\tau}\ |\ \Ref{\ell}{q}{\tau}\ 
	      |\ \Var{\tau_i}{n}\ |\ \Rec{\tau_i}{n}\ |\ \Fix{X}{\tau}\ |\ X$

  Route $r ::= \Base\ |\ \Proj{r}{n}{i}\ |\ \Pay{r}\ |\ \Unroll{\tau}{r} $

  Slot $s ::= \void\ |\ z\ |\ \OwnVal{\alpha}{r}\ |\ \Ref{q}{\alpha}{r} $

  Layout $l ::= \Slot{s}\ |\ \VarVal{s}{l}{n}\ |\ \Rec{l_i}{n}\ |\ \Roll{\tau}{l} $

  Path $p ::= \Base\ |\ \Deref{p}\ |\ \Proj{p}{n}{i}\ |\ \Unroll{\tau}{p} $

  Hole $h ::= \uninit\ |\ \zah\ |\ \RefVal{q}{\tau}\ |\ \Own{\sigma}\ |\ \Var{\tau_i}{n} $

  Shape $\sigma ::= \Hole{h}\ |\ \Rec{\sigma_i}{n}\ |\ \Roll{\tau}{\sigma} $

  \caption{Syntax}
\end{figure}

\begin{figure}[H]
  $H : $ Allocation $\to$ Layout

  $\Gamma : $ Variable $\to$ Type

  $V : $ Variable $\to$ Allocation

  $\Sigma : $ Allocation $\to$ Type

  $\Delta \subseteq $ Type Variable

  $\Psi : $ Allocation $\times$ Route $\to$ Natural

  $\Upsilon : $ Variable $\to$ Shape
  \caption{Environments}
\end{figure}

\section{Runtime Typing}

\begin{figure}[H]
  \begin{mathpar}
    \inferrule[RT-BASE]
      {\Sigma (\alpha) = \tau}
      {\ARType{\Sigma}{\Psi}{\alpha}{\Base}{\tau}}

    \inferrule[RT-PROJ]
      {\ARType{\Sigma}{\Psi}{\alpha}{r}{\Rec{\tau_i}{n}}}
      {\ARType{\Sigma}{\Psi}{\alpha}{\Proj{r}{n}{i}}{\tau_i}}

    \inferrule[RT-PAY]
      {\Psi(\alpha, r) = i \\ \ARType{\Sigma}{\Psi}{\alpha}{r}{\Var{\tau_i}{n}}}
      {\ARType{\Sigma}{\Psi}{\alpha}{\Pay{r}}{\tau_i}}

    \inferrule[RT-UNROLL]
      {\tau = \Fix{X}{\tau'} \\ \ARType{\Sigma}{\Psi}{\alpha}{r}{\tau}}
      {\ARType{\Sigma}{\Psi}{\alpha}{\Unroll{\tau}{r}}{\Subst{X}{\tau}{\tau'}}}
  \end{mathpar}
  \caption{Route Typing}
\end{figure}

\begin{figure}[H]
  \begin{mathpar}
    \infer[ST-VOIDINT]
      { }
      {\RTType{\Sigma}{\Psi}{\void}{\zah}}

    \infer[ST-VOIDOWN]
      { }
      {\RTType{\Sigma}{\Psi}{\void}{\Own{\tau}}}

    \infer[ST-VOIDREF]
      { }
      {\RTType{\Sigma}{\Psi}{\void}{\Ref{\ell}{q}{\tau}}}

    \infer[ST-INT]
      { }
      {\RTType{\Sigma}{\Psi}{z}{\zah}}

    \infer[ST-OWN]
      {\ARType{\Sigma}{\Psi}{\alpha}{r}{\tau}}
      {\RTType{\Sigma}{\Psi}{\OwnVal{\alpha}{r}}{\Own{\tau}}}

    \infer[ST-REF]
      {\ARType{\Sigma}{\Psi}{\alpha}{r}{\tau}}
      {\RTType{\Sigma}{\Psi}{\Ref{q}{\alpha}{r}}{\Ref{\ell}{q}{\tau}}}
  \end{mathpar}
  \caption{Slot Typing}
\end{figure}

\begin{figure}[H]
  \begin{mathpar}
    \infer[LT-SLOT]
      {\RTType{\Sigma}{\Psi}{s}{\tau}}
      {\RTType{\Sigma}{\Psi}{\Slot{s}}{\tau}}
    
    \infer[LT-VOIDVAR]
      { }
      {\RTType{\Sigma}{\Psi}{\VarVal{\void}{\Slot{\void}}{n}}{\Var{\tau_i}{n}}}

    \infer[LT-VAR]
      {\RTType{\Sigma}{\Psi}{l}{\tau_i}}
      {\RTType{\Sigma}{\Psi}{\VarVal{i}{l}{n}}{\Var{\tau_i}{n}}}

    \infer[LT-REC]
      {\forall i.\ \RTType{\Sigma}{\Psi}{l_i}{\tau_i}}
      {\RTType{\Sigma}{\Psi}{\Rec{l_i}{n}}{\Rec{\tau_i}{n}}}

    \infer[LT-ROLL]
      {\tau = \Fix{X}{\tau'} \\ \RTType{\Sigma}{\Psi}{l}{\Subst{X}{\tau}{\tau'}}}
      {\RTType{\Sigma}{\Psi}{\Roll{\tau}{l}}{\tau}}
  \end{mathpar}
  \caption{Layout Typing}
\end{figure}

\begin{figure}[H]
  \begin{mathpar}
    \mprset{flushleft}
    \infer
      {\dom(H) = \dom(\Sigma) \\\\
       \forall \alpha \in \dom(H).\ \RTType{\Sigma}{\Psi}{H(\alpha)}{\Sigma(\alpha)} \\\\
       \forall \alpha \in \dom(\Sigma).\ \Sigma(\alpha)\ \textrm{closed} \\\\
       \forall (\alpha, r) \in \dom(\Psi).\ \Read{H}{\alpha}{r}{\VarVal{\Psi(\alpha, r)}{l}{n}}
      }
      {\HWF{H}{\Sigma}{\Psi}}
  \end{mathpar}
  \caption{Heap Well-Formed}
\end{figure}

\section{Reading}

\begin{figure}[H]
  \begin{mathpar}
    \infer[RD-BASE]
      {H(\alpha) = l}
      {\Read{H}{\alpha}{\Base}{l}}

    \infer[RD-PROJ]
      {\Read{H}{\alpha}{r}{\Rec{l_i}{n}}}
      {\Read{H}{\alpha}{\Proj{r}{n}{i}}{l_i}}

    \infer[RD-PAY]
      {\Read{H}{\alpha}{r}{\VarVal{s}{l}{n}}}
      {\Read{H}{\alpha}{\Pay{r}}{l}}

    \infer[RD-UNROLL]
      {\Read{H}{\alpha}{r}{\Roll{\tau'}{l}}}
      {\Read{H}{\alpha}{\Unroll{\tau}{r}}{l}}

  \end{mathpar}
  \caption{Reading}
\end{figure}

\newtheorem{lem}{Lemma}

\begin{lem}[Read Uniqueness]
  $\Read{H}{\alpha}{r}{l}\ \land\ \Read{H}{\alpha}{r}{l'}\ \Rightarrow\ l = l'$.
\end{lem}

\begin{proof}
  Induction on the derivation of $\Read{H}{\alpha}{r}{l}$.

  \textsc{Case RD-BASE}:
    Then $r = \Base$ and $H(\alpha) = l$.

    By inversion via \textsc{RD-BASE} on $\Read{H}{\alpha}{\Base}{l'}$, $H(\alpha) = l'$.
    Ergo, $l = l'$.

  \textsc{Case RD-PROJ}:
    Then $r = \Proj{r'}{n}{i}$, $l = l_i$, and $\Read{H}{\alpha}{r'}{\Rec{l_i}{n}}$.

    By inversion via \textsc{RD-PROJ} on $\Read{H}{\alpha}{\Proj{r'}{n}{i}}{l'}$,
    $l' = l'_i$ and $\Read{H}{\alpha}{r'}{\Rec{l'_i}{n}}$.

    By induction, $\Rec{l_i}{n} = \Rec{l'_i}{n}$. Thus, $l_i = l'_i$.

  \textsc{Case RD-PAY}:
    Then $r = \Pay{r'}$ and $\Read{H}{\alpha}{r'}{\VarVal{s}{l}{n}}$.

    By inversion via \textsc{RD-PAY} on $\Read{H}{\alpha}{\Pay{r'}}{l'}$,
    $\Read{H}{\alpha}{r'}{\VarVal{s'}{l'}{n'}}$.

    By induction, $\VarVal{s}{l}{n} = \VarVal{s'}{l'}{n'}$. Ergo, $l = l'$.

  \textsc{Case RD-UNROLL}:
    Then $r = \Unroll{\tau}{r'}$ and $\Read{H}{\alpha}{r'}{\Roll{\tau'}{l}}$.

    By inversion via \textsc{RD-UNROLL} on $\Read{H}{\alpha}{\Unroll{\tau}{r'}}{l'}$,
    $\Read{H}{\alpha}{r'}{\Roll{\tau''}{l'}}$.

    By induction, $\Roll{\tau'}{l} = \Roll{\tau''}{l'}$. Thus, $l = l'$.
\end{proof}

\begin{lem}[Read Safety]
  $\HWF{H}{\Sigma}{\Psi}\ \land\ \ARType{\Sigma}{\Psi}{\alpha}{r}{\tau}\ \Rightarrow\ 
  \exists l. \Read{H}{\alpha}{r}{l} \land \RTType{\Sigma}{\Psi}{l}{\tau}$.
\end{lem}

\begin{proof}
  TODO transcribe from paper.
  Mostly straightforward induction on $\ARType{\Sigma}{\Psi}{\alpha}{r}{\tau}$.
  Utilizes Read Uniqueness in the \textsc{RD-PAY} case.
\end{proof}

\end{document}
