\section*{Abstract}
Rust is a new systems language that uses some advanced type system features,
specifically affine types and regions, to statically guarantee memory
safety and eliminate the need for a garbage collector.
While each individual addition to the type system is well understood
in isolation and are known to be sound, the combined system is not.
Furthermore, Rust uses a novel checking scheme for its regions, known
as the Borrow Checker, that is not known to be correct.
Since Rust's goal is to be a safer alternative to C/C++, we should
ensure that this safety scheme actually works. We present a formal
semantics that captures the key features relevant to memory safety,
unique pointers and borrowed references, specifies how they guarantee
memory safety, and describes the operation of the Borrow Checker.
We use this model to prove the soudness of some core operations
and justify the conjecture that the model, as a whole, is sound.
Additionally, our model provides a syntactic version of the Borrow
Checker, which may be more understandable than the non-syntactic version
in Rust.

\section*{Overview}
The Rust Programming Language~\cite{rust} makes strong claims about 
ensuring memory safety without garbage collection.
We would like to prove that those claims are true.
To that end, we use a small model of Rust, called Patina, that characterizes the key
features of Rust under the most suspicion, namely its memory management.

Rust memory management has two goals:
no memory should ever become unreachable without being deallocated
and no uninitialized memory should ever be read.
Rust tries to achieve this by maintaining two invariants:
all memory has a unique owner responsible for deallocating it and
no memory is ever simultaneously aliased and mutable.
These invariants simplify the situation enough so that
Rust only needs to track which L-values are uninitialized and which have been borrowed.
Ownership tracking of heap memory is managed by unique pointers.
Safe aliasing is managed by borrowed references.

The Patina model has three layers.
The innermost layer deals with L-values and ensures 
no uninitialized data is ever used, which includes ensuring
that uninitialized pointers and null pointers are never dereferenced.
It also ensures that compile-time initialization information correctly
models the runtime memory.
The middle layer deals with R-values.
It ensures that any L-values used do not violate initialization or borrow restrictions.
It also ensures that borrowed references are not created unless they are safe.
The outer layer deals with statements.
It mostly just chains together the guarantees of the L-value and R-value layers.
However, it is also responsible for ensuring no leaks would be created when deallocating memory.

\subsection*{Unique Pointers in Rust}
In Rust, unique pointers are the owners of heap memory.
Heap memory is allocated when a new unique pointer is created.
Heap memory is freed when a unique pointer falls out of scope.
\begin{verbatim}
{
  let x: ~int; // A stack variable containing a unique pointer to an integer
  x = ~3; // Allocates a heap integer, initializes it with 3, and stores the pointer in x
  // The heap memory owned by x is freed when it falls out of scope
}
\end{verbatim}

To avoid double frees, unique pointers must remain unique.
Thus, when a unqiue pointer would be copied the original must be rendered unsuable.
That is, they are moved rather than copied.
\begin{verbatim}
{
  let x: ~int = ~3;
  let y: ~int = x; // x is moved into y. x is no longer usable.
  let z: ~int = x; // ERROR!
}
\end{verbatim}

However, these deinitialized paths can be reinitialized.
\begin{verbatim}
{
  let x: ~int = ~3;
  let y: ~int = x; // x is now deinitialized
  x = ~1; // x is initialized again
}
\end{verbatim}

Unique pointers can also be freed if they would be leaked by assignment.
\begin{verbatim}
{
  let x: ~~int = ~~3;
  *x = ~1; // The ~3 that *x points too would be leaked here. It is freed instead.
}
\end{verbatim}

This is not a dynamic check. 
The compiler detects when heap memory should be freed and inserts the necessary code.

\subsection*{Unique Pointers in Patina}
When unique pointers fall out of scope in Rust, the compiler inserts code at the end
of the block that will actually free the allocated heap memory. This code will
traverse the entire owned data structure and free memory without leaking anything.
In the case of recursive data structures, this code will be a recursive function.
Rather than model such complex behavior as a primitive in Patina, we will use only
a shallow free statement. Aside from making the model simpler, this also provides us
with a means of checking that the code Rust inserts to free memory is correct,
i.e.\ by encoding it in terms of Patina's shallow frees.
The only way to deallocate a unique pointer in Patina is with these explicit frees.
\begin{verbatim}
{
  let x: ~~int = ~~3;
  //free(x); // ERROR! would leak *x
  // The proper way
  free(*x);
  free(x);
}
\end{verbatim}
However, the free statement is only valid for initialized pointers, which prevents double frees.
\begin{verbatim}
{
  let x: ~int = ~3;
  free(x); // *x is now deallocated. x is uninitialized
  free(x); // ERROR! x is not initialized
}
\end{verbatim}
Finally, the free statement requires that the pointer is unaliased, preventing dangling pointers.
\begin{verbatim}
{
  let x: ~int = ~3;
  // Create an immutable borrowed reference to *x with &
  // Immutable borrowed references to some type A are denoted by &A
  let y: &int = &*x;
  free(x); // ERROR! would make y a dangling pointer
}
\end{verbatim}

\subsection*{Borrowed References}
Often, particularly in functions, we want to use some memory, but do not intend to free it.
That is, we want to borrow access to memory owned by something else.
This is fine for copyable values, like integers, 
but is tedious for noncopyable values such as unique pointers.
To avoid freeing a unique pointer argument at the end of the function body,
it must be returned from the function.
Effectively, the programmer must thread noncopyable values through their function calls.
\begin{verbatim}
fn foo(x: ~int) -> (int, ~int) {
  return (*x + 1, x)
}

{
  let x1: ~int = ~1;
  let (y,x2): (int, ~int) = foo(x);
  // y = 2, x1 is no longer valid, x2 = ~1
}
\end{verbatim}

Borrowed references allow programmers to have temporary access to a value,
but they do not confer ownership so this tedium is not necessary.
\begin{verbatim}
fn foo(x: &int) -> int {
  return (*x + 1)
}

{
  let x: ~int = ~1;
  let y: int = foo(&*x); // Rust lets us write foo(x) here and will insert the &* for us
  // x = ~1, y = 2
}
\end{verbatim}

However, unrestricted borrowed references would open a hole in our memory safety
by enabling aliased, mutable memory.
\begin{verbatim}
{
  let x: ~int = ~1;
  let y: &~int = &x; // x and *y are the same memory location
  let z: ~int = x; // x is no longer usable - effectively x is uninitialized memory
  let w: int = **y; // ERROR! *y is uninitialized now, so **y dereferences a null pointer!
}

{
  let x: &int;
  {
    let y: int = 3;
    y = &x;
  } // x would be freed here
  let z: int = *x // ERROR *y would point to unallocated memory
}

{
  let x: Option<int> = Some(3);
  let y: &int = match x {
    Some(ref z) => z,
    None => fail!(), // Impossible
  }
  x = None // payload is now uninitialized
  let z: int = *y; // ERROR! *y points to uninitialized memory
}
\end{verbatim}

Aliased, mutable memory can be avoided in two ways: forbidding mutability or forbidding aliasing.
Correspondingly, Rust has two kinds of borrowed references.
Immutable borrows, denoted \texttt{\&}, are aliasable,
but require all memory reachable through them to be immutable for the duration of the borrow.
\begin{verbatim}
{
  let x: ~int = ~1;
  let y: &~int = &x; // this immutable borrow prevents x from being changed
  let z: ~int = x; // Rust will not let this typecheck because it would change x 
}
\end{verbatim}

Conversely, mutable borrows, denoted \texttt{\&mut}, are mutable,
but require all memory reachable through them to be \emph{only} accessible through the borrow
for the duration. That is, they guarantee unique access.
\begin{verbatim}
{
  let x: ~int = ~1;
  let y: &mut ~int = &mut x; // this mutable borrow prevents others from using x
  let z: ~int = x; // Rust will not let this typecheck because it would access x
}
\end{verbatim}

Finally, both kinds of borrowed reference require that the referent outlive the reference,
which prevents dangling references.
\begin{verbatim}
fn foo() -> &int {
  let x: int = 1;
  return &x; // Rust will not let this typecheck because it would be a dangling pointer
}
\end{verbatim}

\section*{Types}
Values in Patina can be described by the following types:
\[
\begin{array}{lccl}
\textrm{Lifetime} & \lt & & \\
\textrm{Type Variable} & X & & \\
\textrm{Qualifier} & q & \bnfdef & \qimm \bnfalt \qmut \\
\textrm{Type} & \gt & \bnfdef & \tyint \bnfalt \own{\gt} \bnfalt \tyref{\lt}{q}{\gt} \bnfalt 
				\subvar{\gt}{i}{n} \bnfalt \subrec{\gt}{i}{n} \bnfalt 
				\tyfix{X}{\gt} \bnfalt X \\
\end{array}
\]

$\own{\gt}$ is a unique pointer to a $\gt$.
$\tyref{\lt}{q}{\gt}$ is a borrowed reference to a $\gt$
providing mutability guarantee $q$ for lifetime $\lt$, which is Rust's name
for regions associated with stack frames.
$\subvar{\gt}{i}{n}$ is a discriminated union or a variant type.
$\subrec{\gt}{i}{n}$ is a tuple type.
Finally, $\tyfix{X}{\gt}$ is a recursive type.
