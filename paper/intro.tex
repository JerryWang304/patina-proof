%\section*{Introduction}
%Rust claims to ensure memory safety without a garbage collector.
%We would like to verify this claim.

%Rust ensures safety by combining affine types with checked borrowed references.
%Affine types ensure that every piece of memory has a unqiue owner responsible for deallocation.
%Borrowed references allow limited aliasing that avoids 
%aliased, mutable memory and dangling references
%Rust's usage of affine types for memory management is standard except for one addition.
%Rust allows consumed affine cells that are still in scope to be re-initialized and used again.
%Rust's borrowed references utilize a region system very similar to Cyclone's.
%The primary difference is in the details of the borrow checker.
%Our main goal is to prove that these differences do not introduce unsoundness.

%\section*{Patina}
%We work with a small core model of Rust called Patina, which focuses
%on the memory management aspects of Rust.
%Unlike Rust, Patina uses explicit heap deallocation and does not support closures.
%Patina has three layers: L-values, R-values, and statements.
%We will discuss them in order.

\section*{Overview}
Rust makes strong claims about ensuring memory safety without garbage collection.
We would like to prove that those claims are true.
To that end, we use a small model of Rust, called Patina, that characterizes the key
features of Rust under the most suspicion, namely its memory management.

Rust memory management has two goals:
no memory should ever be orphaned and no uninitialized memory should ever be read.
Rust tries to achieve this by maintaining two invariants:
all memory has a unique owner responsible for deallocating it and
no memory is ever simultaneously aliased and mutable.
These invariants simplify the situation enough so that
Rust only needs to track which L-values are uninitialized and which have been borrowed.
Ownership tracking of heap memory is managed by unique pointers.
Safe aliasing is managed by borrowed references.

The Patina model has three layers.
The innermost layer deals with L-values and ensures no uninitialized pointer
ever needs to be dereferenced. It also ensures that initialization data correctly
models the runtime memory.
The middle layer deals with R-values.
It ensures that an L-values used do not violate initialization or borrow restrictions.
It also ensures that borrowed references are not created unless they are safe.
The outer layer deals with statements.
It mostly just chains together the guarantees of the L-value and R-value layers.
However, it is also responsible for ensuring no orphans would be created when deallocating memory.

\section*{Types}
Values in Patina can be described by the following types:
\[
\begin{array}{lccl}
\textrm{Lifetime} & \lt & & \\
\textrm{Type Variable} & X & & \\
\textrm{Qualifier} & q & \bnfdef & \qimm \bnfalt \qmut \\
\textrm{Type} & \gt & \bnfdef & \tyint \bnfalt \own{\gt} \bnfalt \tyref{\lt}{q}{\gt} \bnfalt 
				\subvar{\gt}{i}{n} \bnfalt \subrec{\gt}{i}{n} \bnfalt 
				\tyfix{X}{\gt} \bnfalt X \\
\end{array}
\]

$\own{\gt}$ is a unique pointer to a $\gt$.
$\tyref{\lt}{q}{\gt}$ is a borrowed reference to a $\gt$
providing mutability guarantee $q$ for lifetime $\lt$.
$\subvar{\gt}{i}{n}$ is a variant type.
$\subrec{\gt}{i}{n}$ is a tuple type.
Finally, $\tyfix{X}{\gt}$ is a recursive type.
