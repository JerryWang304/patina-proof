\section*{Overview}
Rust makes strong claims about ensuring memory safety without garbage collection.
We would like to prove that those claims are true.
To that end, we use a small model of Rust, called Patina, that characterizes the key
features of Rust under the most suspicion, namely its memory management.

Rust memory management has two goals:
no memory should ever be orphaned and no uninitialized memory should ever be read.
Rust tries to achieve this by maintaining two invariants:
all memory has a unique owner responsible for deallocating it and
no memory is ever simultaneously aliased and mutable.
These invariants simplify the situation enough so that
Rust only needs to track which L-values are uninitialized and which have been borrowed.
Ownership tracking of heap memory is managed by unique pointers.
Safe aliasing is managed by borrowed references.

The Patina model has three layers.
The innermost layer deals with L-values and ensures no uninitialized pointer
ever needs to be dereferenced. It also ensures that initialization data correctly
models the runtime memory.
The middle layer deals with R-values.
It ensures that an L-values used do not violate initialization or borrow restrictions.
It also ensures that borrowed references are not created unless they are safe.
The outer layer deals with statements.
It mostly just chains together the guarantees of the L-value and R-value layers.
However, it is also responsible for ensuring no orphans would be created when deallocating memory.

\subsection*{Unique Pointers in Rust}
In Rust, unique pointers are the owners of heap memory.
Heap memory is allocated when a new unique pointer is created.
Heap memory is freed when a unique pointer falls out of scope.
\begin{verbatim}
{
  let x: ~int; // A stack variable containing a unique pointer to an integer
  x = ~3; // Allocates a heap integer, initializes it with 3, and stores the pointer in x
  // The heap memory owned by x is freed when it falls out of scope
}
\end{verbatim}

To avoid double frees, unique pointers must remain unique.
Thus, when a unqiue pointer would be copied the original must be rendered unsuable.
That is, they are moved rather than copied.
\begin{verbatim}
{
  let x: ~int = ~3;
  let y: ~int = x; // x is moved into y. x is no longer usable.
  let z: ~int = x; // ERROR!
}
\end{verbatim}

However, these deinitialized paths can be reinitialized.
\begin{verbatim}
{
  let x: ~int = ~3;
  let y: ~int = x; // x is now deinitialized
  x = ~1; // x is initialized again
}
\end{verbatim}

Unique pointers can also be freed if they would be orphaned by assignment.
\begin{verbatim}
{
  let x: ~~int = ~~3;
  *x = ~1; // The ~3 that *x points too would be orphaned here. It is freed instead.
}
\end{verbatim}

This is not a dynamic check. 
The compiler detects when heap memory should be freed and inserts the necessary code.

\subsection*{Unique Pointers in Patina}
To check that the Rust compiler does this correctly, Patina uses a shallow free statement.
The only way to deallocate a unique pointer in Patina is with these explicit frees.
\begin{verbatim}
{
  let x: ~~int = ~~3;
  //free(x); // ERROR! would orphan *x
  // The proper way
  free(*x);
  free(x);
}
\end{verbatim}
However, the free statement is only valid for initialized pointers, which prevents double frees.
\begin{verbatim}
{
  let x: ~int = ~3;
  free(x); // *x is now deallocated. x is uninitialized
  free(x); // ERROR! x is not initialized
}
\end{verbatim}
Finally, the free statement requires that the pointer is unaliased, preventing dangling pointers.
\begin{verbatim}
{
  let x: ~int = ~3;
  let y: &int = &*x; // Create an immutable borrowed reference to *x
  free(x); // ERROR! would make y a dangling pointer
}
\end{verbatim}

\subsection*{Borrowed Referenced REDUX}
Often, particularly in functions, we want to use some memory, but do not intend to free it.
That is, we want to borrow access to memory owned by something else.
This is fine for copyable values, like integers, 
but is tedious for noncopyable values such as unique pointers.
To avoid freeing a unique pointer argument at the end of the function body,
it must be returned from the function.
Effectively, the programmer must thread noncopyable values through their function calls.
\begin{verbatim}
fn foo(x: ~int) -> (int, ~int) {
  return (*x + 1, x)
}

{
  let x1: ~int = ~1;
  let (y,x2): (int, ~int) = foo(x);
  // y = 2, x1 is no longer valid, x2 = ~1
}
\end{verbatim}

Borrowed references allow programmers to have temporary access to a value,
but they do not confer ownership so this tedium is not necessary.
\begin{verbatim}
fn foo(x: &int) -> int {
  return (*x + 1)
}

{
  let x: ~int = ~1;
  let y: int = foo(&*x);
  // x = ~1, y = 2
}
\end{verbatim}

However, unrestricted borrowed references would open a hole in our memory safety
by enabling aliased, mutable memory.
\begin{verbatim}
{
  let x: ~int = ~1;
  let y: &~int = &x; // x and *y are the same memory location
  let z: ~int = x; // x is no longer usable - effectively x is uninitialized memory
  let w: int = **y; // ERROR! *y is uninitialized now, so **y dereferences a null pointer!
}

{
  let x: &int;
  {
    let y: int = 3;
    y = &x;
  } // x would be freed here
  let z: int = *x // ERROR *y would point to unallocated memory
}

{
  let x: Option<int> = Some(3);
  let y: &int = match x {
    Some(ref z) => z,
    None => fail!(), // Impossible
  }
  x = None // payload is now uninitialized
  let z: int = *y; // ERROR! *y points to uninitialized memory
}
\end{verbatim}

Aliased, mutable memory can be avoided in two ways: forbidding mutability or forbidding aliasing.
Correspondingly, Rust has two kinds of borrowed references.
Immutable borrows, denoted \texttt{\&}, are aliasable,
but require all memory reachable through them to be immutable for the duration of the borrow.
\begin{verbatim}
{
  let x: ~int = ~1;
  let y: &~int = &x; // this immutable borrow prevents x from being changed
  let z: ~int = x; // Rust will not let this typecheck because it would change x 
}
\end{verbatim}

Conversely, mutable borrows, denoted \texttt{\&mut}, are mutable,
but require all memory reachable through them to be \emph{only} accessible through the borrow
for the duration. That is, they guarantee unique access.
\begin{verbatim}
{
  let x: ~int = ~1;
  let y: &mut ~int = &mut x; // this mutable borrow prevents others from using x
  let z: ~int = x; // Rust will not let this typecheck because it would access x
}
\end{verbatim}

Finally, both kinds of borrowed reference require that the referent outlive the reference,
which prevents dangling references.
\begin{verbatim}
fn foo() -> &int {
  let x: int = 1;
  return &x; // Rust will not let this typecheck because it would be a dangling pointer
}
\end{verbatim}


%\subsection*{Borrowed References}
%Borrowed references are a means to provide safe, temporary aliases in Rust.
%They do so by enforcing two invariants.
%The first is that references are always valid.
%\begin{verbatim}
%{
%  let x: int; // An uninitialized stack integer
%  let y: &int = &x; // ERROR! *y would point to uninitialized memory
%}
%\end{verbatim}
%This also extends to cases where the referent falls out of scope too soon.
%\begin{verbatim}
%{
%  let y: &int;
%  {
%    let x: int = 3;
%    y = &x; // ERROR! x does not live long enough
%  } // x would be freed here
%  // *y would point to unallocated memory here
%}
%\end{verbatim}
%The second invariant is to prevent any memory from being simultaneously aliased and mutable.
%This is to avoid situtations like the following:
%\begin{verbatim}
%{
%  let x: Option<int> = Some(3);
%  let y: &int = match x {
%    Some(ref z) => z,
%    None => fail!(), // Impossible
%  }
%  // If x is mutable, then the payload 3 is both aliased and mutable
%  x = None // The payload is now uninitialized so *y is a dangling pointer
%}
%\end{verbatim}
%Therefore immutable borrows freeze the underlying data.
%It cannot be mutated by anything while the borrow exists.
%However, it is freely copyable.
%\begin{verbatim}
%{
%  let x: int = 3;
%  let y: &int = &x;
%  let z: &int = y; // Both y and z are readable
%  x = 2; // ERROR! x is frozen by y
%}
%\end{verbatim}
%Conversely, mutable borrows forbid all other access to the underlying data.
%It does allow the data to be mutated, but it is an affine datatype like unique pointers.
%\begin{verbatim}
%{
%  let x: int = 3;
%  let y: &mut int = &mut x;
%  //let z: int = x; // ERROR! cannot use x while mutable borrowed
%  let z: int = *y; // OK
%
%  let w: &mut int = y; // Moves y into w. y is not uninitialized
%  z = *y; // ERROR! y is uninitialized
%}
%\end{verbatim}
%As with unique pointers, these checks are all static.

\section*{Types}
Values in Patina can be described by the following types:
\[
\begin{array}{lccl}
\textrm{Lifetime} & \lt & & \\
\textrm{Type Variable} & X & & \\
\textrm{Qualifier} & q & \bnfdef & \qimm \bnfalt \qmut \\
\textrm{Type} & \gt & \bnfdef & \tyint \bnfalt \own{\gt} \bnfalt \tyref{\lt}{q}{\gt} \bnfalt 
				\subvar{\gt}{i}{n} \bnfalt \subrec{\gt}{i}{n} \bnfalt 
				\tyfix{X}{\gt} \bnfalt X \\
\end{array}
\]

$\own{\gt}$ is a unique pointer to a $\gt$.
$\tyref{\lt}{q}{\gt}$ is a borrowed reference to a $\gt$
providing mutability guarantee $q$ for lifetime $\lt$.
$\subvar{\gt}{i}{n}$ is a variant type.
$\subrec{\gt}{i}{n}$ is a tuple type.
Finally, $\tyfix{X}{\gt}$ is a recursive type.
